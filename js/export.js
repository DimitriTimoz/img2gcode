/**
 * Export Functionality Module
 * Handles G-code export for laser engraving on Ender 3
 */

// Laser engraving settings for Ender 3
var LASER_CONFIG = {
    maxPower: 255,        // Maximum fan PWM value (0-255)
    minPower: 5,          // Minimum power for light engraving (avoid very light burns)
    feedRate: 1000,       // Feed rate in mm/min for engraving
    travelRate: 3000,     // Travel rate for non-cutting moves
    rapidRate: 5000,      // Rapid movement rate for long distances
    laserOn: 'M106',      // Fan on command (controls laser)
    laserOff: 'M107',     // Fan off command
    units: 'G21',         // Millimeters
    positioning: 'G90',   // Absolute positioning
    homeX: 0,             // Home X position
    homeY: 0,             // Home Y position
    resolution: 10,       // Default resolution in pixels per mm (0.1mm precision)
    burnDelay: 0,         // Delay in ms between power changes (for laser stabilization)
    safetyHeight: 0,      // Z height for safety (if applicable)
    powerCurve: 'linear', // Power curve: 'linear', 'exponential', 'custom'
    
    // Enhanced speed settings
    speedProfiles: {
        'slow': { feedRate: 500, travelRate: 1500 },
        'normal': { feedRate: 1000, travelRate: 3000 },
        'fast': { feedRate: 1500, travelRate: 4500 },
        'custom': { feedRate: 1000, travelRate: 3000 }
    },
    currentSpeedProfile: 'normal',
    
    // Enhanced resolution settings
    resolutionPresets: {
        'draft': { resolution: 5, description: '0.2mm - Rapide' },
        'normal': { resolution: 10, description: '0.1mm - Standard' },
        'fine': { resolution: 20, description: '0.05mm - Fin' },
        'ultra': { resolution: 40, description: '0.025mm - Ultra' },
        'custom': { resolution: 10, description: 'Personnalis√©' }
    },
    currentResolutionProfile: 'normal',
    
    // Machine configuration profiles
    machineProfiles: {
        'ender3_standard': {
            name: 'Ender 3 Standard',
            maxPower: 255,
            minPower: 5,
            feedRate: 1000,
            travelRate: 3000,
            laserOn: 'M106',
            laserOff: 'M107',
            powerCurve: 'linear'
        },
        'ender3_high_power': {
            name: 'Ender 3 Haute Puissance',
            maxPower: 255,
            minPower: 15,
            feedRate: 800,
            travelRate: 2500,
            laserOn: 'M106',
            laserOff: 'M107',
            powerCurve: 'exponential'
        }
    },
    currentMachineProfile: 'ender3_standard',
    
    // Advanced settings
    adaptivePower: false,    // Adjust power based on line length
    burnDeepThreshold: 200,  // Grayscale threshold for deep burning
    lightBurnThreshold: 50,  // Grayscale threshold for light burning
    optimizeTravel: true,    // Optimize travel paths
    bidirectionalScan: true  // Use zigzag scanning pattern
};

/**
 * Generate G-code header
 */
function generateGcodeHeader() {
    var header = [
        '; Generated by Image to G-Code Converter - Enhanced Edition',
        '; For Ender 3 with laser engraving (fan-controlled)',
        '; Date: ' + new Date().toLocaleString(),
        '',
        '; Enhanced Configuration:',
        '; - Machine Profile: ' + LASER_CONFIG.currentMachineProfile,
        '; - Power Range: ' + LASER_CONFIG.minPower + '-' + LASER_CONFIG.maxPower + ' PWM',
        '; - Power Curve: ' + LASER_CONFIG.powerCurve,
        '; - Speed Profile: ' + LASER_CONFIG.currentSpeedProfile + ' (' + LASER_CONFIG.feedRate + '/' + LASER_CONFIG.travelRate + ' mm/min)',
        '; - Resolution: ' + LASER_CONFIG.resolution + ' pixels/mm (' + LASER_CONFIG.currentResolutionProfile + ')',
        '; - Adaptive Power: ' + (LASER_CONFIG.adaptivePower ? 'Enabled' : 'Disabled'),
        '; - Travel Optimization: ' + (LASER_CONFIG.optimizeTravel ? 'Enabled' : 'Disabled'),
        '; - Bidirectional Scan: ' + (LASER_CONFIG.bidirectionalScan ? 'Enabled' : 'Disabled'),
        '',
        '; Initialize - No homing required',
        '; Current position will be used as origin (0,0)',
        LASER_CONFIG.units + ' ; Set units to millimeters',
        LASER_CONFIG.positioning + ' ; Absolute positioning',
        'G92 X0 Y0 Z0 ; Set current position as origin (0,0,0)',
        'F' + LASER_CONFIG.travelRate + ' ; Set travel feed rate',
        LASER_CONFIG.laserOff + ' ; Ensure laser is off',
        '',
        '; Begin engraving',
        ''
    ];
    return header.join('\n');
}

/**
 * Generate G-code footer
 */
function generateGcodeFooter() {
    var footer = [
        '',
        '; End engraving',
        LASER_CONFIG.laserOff + ' ; Turn off laser',
        'G0 X0 Y0 ; Return to origin',
        'M84 ; Disable steppers',
        '; End of G-code'
    ];
    return footer.join('\n');
}

/**
 * Convert grayscale value to laser power (0-255)
 * Enhanced with adaptive power and multiple thresholds
 */
function grayscaleToLaserPower(grayscale, lineLength) {
    // Invert grayscale: darker = more power
    var inverted = 255 - grayscale;
    
    // Advanced thresholding
    var lightThreshold = LASER_CONFIG.lightBurnThreshold;
    var deepThreshold = LASER_CONFIG.burnDeepThreshold;
    
    if (inverted < lightThreshold) return 0; // Don't engrave light areas
    
    // Apply power curve
    var normalizedPower;
    if (LASER_CONFIG.powerCurve === 'exponential') {
        // Exponential curve for more aggressive contrast
        normalizedPower = Math.pow(inverted / 255, 0.7);
    } else if (LASER_CONFIG.powerCurve === 'custom') {
        // Custom curve with S-curve for better mid-tones
        var x = inverted / 255;
        normalizedPower = 0.5 * (1 + Math.tanh(4 * (x - 0.5)));
    } else {
        // Linear curve (default)
        normalizedPower = inverted / 255;
    }
    
    // Apply adaptive power based on line length (if enabled)
    if (LASER_CONFIG.adaptivePower && lineLength) {
        var lengthFactor = Math.min(1.2, 1 + (lineLength - 1) * 0.1); // Increase power for longer lines
        normalizedPower *= lengthFactor;
    }
    
    // Enhanced power mapping with threshold zones
    var powerRange = LASER_CONFIG.maxPower - LASER_CONFIG.minPower;
    var laserPower;
    
    if (inverted >= deepThreshold) {
        // Deep burning zone - use higher portion of power range
        var deepRange = (LASER_CONFIG.maxPower - LASER_CONFIG.minPower * 1.5);
        laserPower = Math.round(LASER_CONFIG.minPower * 1.5 + (normalizedPower * deepRange));
    } else {
        // Normal zone - use standard power range
        laserPower = Math.round(LASER_CONFIG.minPower + (normalizedPower * powerRange));
    }
    
    // Ensure we don't go below minimum power for actual burning
    return Math.max(LASER_CONFIG.minPower, Math.min(LASER_CONFIG.maxPower, laserPower));
}

/**
 * Convert canvas to image data (without grid) and generate G-code
 */
function processCanvasToGcode() {
    console.log('Converting canvas to image for laser engraving...');
    
    // Temporarily hide grid elements completely (remove from canvas)
    var gridElements = canvas.getObjects().filter(function(obj) {
        return obj.excludeFromExport;
    });
    
    console.log('Removing', gridElements.length, 'grid elements temporarily');
    gridElements.forEach(function(obj) {
        canvas.remove(obj);
    });
    
    canvas.renderAll();
    
    // For debugging, let's try extracting the entire canvas first (without grid)
    var fabricCanvasElement = canvas.getElement();
    console.log('Fabric canvas element size:', fabricCanvasElement.width, 'x', fabricCanvasElement.height);
    
    // Try full canvas extraction for debugging (clean canvas without grid)
    var debugFullCanvas = document.createElement('canvas');
    var debugFullCtx = debugFullCanvas.getContext('2d');
    debugFullCanvas.width = fabricCanvasElement.width;
    debugFullCanvas.height = fabricCanvasElement.height;
    debugFullCtx.fillStyle = 'white';
    debugFullCtx.fillRect(0, 0, debugFullCanvas.width, debugFullCanvas.height);
    debugFullCtx.drawImage(fabricCanvasElement, 0, 0);
    debugSaveCanvasImage(debugFullCanvas, 'debug_full_canvas_clean.png');
    
    // Check if there are any content objects and their positions
    var objects = canvas.getObjects(); // All remaining objects (no grid)
    console.log('Content objects on canvas:', objects.length);
    objects.forEach(function(obj, index) {
        var bounds = obj.getBoundingRect();
        console.log(`Object ${index}:`, obj.type, 'text:', obj.text || 'N/A', 'at', bounds);
    });
    
    if (objects.length === 0) {
        console.log('No content objects found after grid removal');
        // Restore grid elements
        gridElements.forEach(function(obj) {
            canvas.add(obj);
        });
        canvas.renderAll();
        return '';
    }
    
    // Use the full canvas approach since it's simpler and more reliable
    var fullCanvas = document.createElement('canvas');
    var fullCtx = fullCanvas.getContext('2d');
    fullCanvas.width = fabricCanvasElement.width;
    fullCanvas.height = fabricCanvasElement.height;
    
    // Fill with white background
    fullCtx.fillStyle = 'white';
    fullCtx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
    
    // Draw the clean canvas content
    fullCtx.drawImage(fabricCanvasElement, 0, 0);
    
    // Get image data from full canvas
    var fullImageData = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);
    var data = fullImageData.data;
    
    // Find bounding box of content
    var bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 200);
    
    if (!bounds) {
        console.log('Trying even more lenient threshold...');
        bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 100);
    }
    
    if (!bounds) {
        console.log('Still no content found, using full canvas');
        bounds = { x: 0, y: 0, width: fullCanvas.width, height: fullCanvas.height };
    }
    
    console.log('Content bounds found:', bounds);
    
    // Crop the content
    var croppedData = cropImageData(data, fullCanvas.width, fullCanvas.height, bounds);
    var croppedWidth = bounds.width;
    var croppedHeight = bounds.height;
    
    // Calculate real-world dimensions using enhanced resolution settings
    var resolution = LASER_CONFIG.resolution; // Use configured resolution
    var pixelToMmRatio = 1 / resolution; // Convert resolution to pixel size
    var croppedWidthMm = croppedWidth * pixelToMmRatio;
    var croppedHeightMm = croppedHeight * pixelToMmRatio;
    
    console.log(`Final dimensions: ${croppedWidthMm.toFixed(2)}x${croppedHeightMm.toFixed(2)}mm`);
    console.log(`Resolution: ${resolution.toFixed(2)} pixels/mm (${pixelToMmRatio.toFixed(3)}mm per pixel)`);
    console.log(`Enhanced settings: Power curve: ${LASER_CONFIG.powerCurve}, Adaptive: ${LASER_CONFIG.adaptivePower}, Bidirectional: ${LASER_CONFIG.bidirectionalScan}`);
    
    // Save debug image of cropped content
    var croppedCanvas = document.createElement('canvas');
    var croppedCtx = croppedCanvas.getContext('2d');
    croppedCanvas.width = croppedWidth;
    croppedCanvas.height = croppedHeight;
    var croppedImageData = new ImageData(croppedData, croppedWidth, croppedHeight);
    croppedCtx.putImageData(croppedImageData, 0, 0);
    debugSaveCanvasImage(croppedCanvas, 'debug_cropped_content.png');
    
    // Generate G-code header
    var gcode = [];
    gcode.push('; Canvas raster engraving (cropped): ' + croppedWidthMm.toFixed(2) + 'x' + croppedHeightMm.toFixed(2) + 'mm');
    gcode.push('; Original canvas: ' + WORKSPACE_CONFIG.width + 'x' + WORKSPACE_CONFIG.height + 'mm');
    gcode.push('; Resolution: ' + resolution.toFixed(2) + ' pixels/mm (' + (1/resolution).toFixed(3) + 'mm per pixel)');
    gcode.push('; Cropped pixels: ' + croppedWidth + 'x' + croppedHeight);
    gcode.push('; Origin: Current printer position (bottom-left of workspace)');
    gcode.push('');
    
    var pixelSize = 1 / resolution; // Size of each pixel in mm
    var currentLaserPower = 0;
    var lastX = 0;
    
    // Process line by line (raster scan) - start from bottom (Y=0) and work up
    // Canvas coordinates are top-down, but we want bottom-left origin for G-code
    for (var canvasY = croppedHeight - 1; canvasY >= 0; canvasY--) {
        var yPos = (croppedHeight - 1 - canvasY) * pixelSize; // Convert to bottom-left coordinate system
        var rowHasContent = false;
        var rowData = [];
        
        // Pre-scan the row to see if it has any content
        for (var x = 0; x < croppedWidth; x++) {
            var pixelIndex = (canvasY * croppedWidth + x) * 4;
            var r = croppedData[pixelIndex];
            var g = croppedData[pixelIndex + 1];
            var b = croppedData[pixelIndex + 2];
            var alpha = croppedData[pixelIndex + 3];
            
            // Convert to grayscale
            var grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            var laserPower = grayscaleToLaserPower(grayscale, 1); // Basic call, will enhance for line length
            
            rowData.push({
                x: x,
                power: laserPower,
                grayscale: grayscale
            });
            
            if (laserPower > 0) {
                rowHasContent = true;
            }
        }
        
        if (!rowHasContent) {
            continue; // Skip empty rows
        }
        
        // Optimize row direction (bidirectional scanning if enabled)
        var rowIndex = croppedHeight - 1 - canvasY;
        var isEvenRow = (rowIndex % 2) === 0;
        if (LASER_CONFIG.bidirectionalScan && !isEvenRow) {
            rowData.reverse(); // Reverse odd rows for zigzag pattern
        }
        
        // Move to start of row
        var startX = isEvenRow ? 0 : (croppedWidth - 1) * pixelSize;
        if (Math.abs(startX - lastX) > 0.1) { // Only move if significant distance
            var moveRate = LASER_CONFIG.optimizeTravel ? LASER_CONFIG.rapidRate : LASER_CONFIG.travelRate;
            gcode.push('G0 X' + startX.toFixed(2) + ' Y' + yPos.toFixed(2) + ' F' + moveRate + ' ; Move to row ' + rowIndex);
            lastX = startX;
        } else {
            gcode.push('G0 Y' + yPos.toFixed(2) + ' ; Next row ' + rowIndex);
        }
        
        // Process pixels in this row with enhanced features
        var segmentStart = null;
        var segmentPower = 0;
        var segmentLength = 0;
        
        for (var i = 0; i < rowData.length; i++) {
            var pixel = rowData[i];
            var xPos = pixel.x * pixelSize;
            
            if (pixel.power > 0) {
                if (segmentStart === null) {
                    // Start new laser segment
                    segmentStart = xPos;
                    segmentLength = 1;
                    
                    // Calculate adaptive power for this pixel
                    var adaptivePower = pixel.power;
                    if (LASER_CONFIG.adaptivePower) {
                        // Look ahead to estimate segment length
                        var lookAheadLength = 1;
                        for (var j = i + 1; j < Math.min(i + 10, rowData.length); j++) {
                            if (rowData[j].power > 0) {
                                lookAheadLength++;
                            } else {
                                break;
                            }
                        }
                        adaptivePower = grayscaleToLaserPower(pixel.grayscale, lookAheadLength);
                    }
                    
                    segmentPower = adaptivePower;
                    
                    if (currentLaserPower !== adaptivePower) {
                        gcode.push('M106 S' + adaptivePower + ' ; Laser power ' + Math.round((adaptivePower/255)*100) + '%');
                        currentLaserPower = adaptivePower;
                    }
                    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Engraving speed');
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Start burn');
                } else if (Math.abs(pixel.power - segmentPower) > 5) {
                    // Power change - end current segment and start new one
                    segmentLength++;
                    var adaptivePower = LASER_CONFIG.adaptivePower ? 
                        grayscaleToLaserPower(pixel.grayscale, segmentLength) : pixel.power;
                    
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Continue burn');
                    gcode.push('M106 S' + adaptivePower + ' ; Power change to ' + Math.round((adaptivePower/255)*100) + '%');
                    segmentPower = adaptivePower;
                    currentLaserPower = adaptivePower;
                } else {
                    // Continue current segment
                    segmentLength++;
                    if (i === rowData.length - 1 || i % 5 === 0) { // Output position every 5 pixels or at end
                        gcode.push('G1 X' + xPos.toFixed(2) + ' ; Burn');
                    }
                }
            } else {
                if (segmentStart !== null) {
                    // End laser segment
                    gcode.push(LASER_CONFIG.laserOff + ' ; End burn segment');
                    currentLaserPower = 0;
                    segmentStart = null;
                    segmentLength = 0;
                }
                
                // Enhanced travel optimization - skip to next burning pixel if there are any
                if (LASER_CONFIG.optimizeTravel) {
                    var nextBurnIndex = -1;
                    for (var j = i + 1; j < rowData.length; j++) {
                        if (rowData[j].power > 0) {
                            nextBurnIndex = j;
                            break;
                        }
                    }
                    
                    var skipThreshold = Math.max(3, Math.round(LASER_CONFIG.resolution * 0.5)); // Dynamic threshold based on resolution
                    if (nextBurnIndex > -1 && nextBurnIndex - i > skipThreshold) {
                        // Jump to next burn area if it's far enough
                        var nextXPos = rowData[nextBurnIndex].x * pixelSize;
                        var moveRate = LASER_CONFIG.rapidRate;
                        gcode.push('G0 X' + nextXPos.toFixed(2) + ' F' + moveRate + ' ; Skip to next burn area');
                        i = nextBurnIndex - 1; // -1 because loop will increment
                        lastX = nextXPos;
                    }
                }
            }
            
            lastX = xPos;
        }
        
        // Ensure laser is off at end of row
        if (currentLaserPower > 0) {
            gcode.push(LASER_CONFIG.laserOff + ' ; End of row');
            currentLaserPower = 0;
        }
        
        // Progress indicator
        if (rowIndex % 10 === 0) {
            var progress = Math.round((rowIndex / croppedHeight) * 100);
            gcode.push('; Progress: ' + progress + '% (row ' + rowIndex + '/' + croppedHeight + ')');
        }
    }
    
    // Restore grid elements
    console.log('Restoring', gridElements.length, 'grid elements');
    gridElements.forEach(function(obj) {
        canvas.add(obj);
    });
    canvas.renderAll();
    
    return gcode.join('\n');
}

/**
 * Process text object and generate G-code for vector engraving
 */
function processTextToGcode(textObj) {
    console.log('Processing text for laser engraving...');
    
    var bounds = textObj.getBoundingRect();
    var xOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.left - WORKSPACE_CONFIG.usableArea.offsetX);
    var yOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.top - WORKSPACE_CONFIG.usableArea.offsetY);
    var widthMm = WORKSPACE_CONFIG.pixelsToMm(bounds.width);
    var heightMm = WORKSPACE_CONFIG.pixelsToMm(bounds.height);
    
    var gcode = [];
    gcode.push('; Vector text engraving: "' + textObj.text + '"');
    gcode.push('; Font: ' + textObj.fontFamily + ', Size: ' + WORKSPACE_CONFIG.pixelsToMm(textObj.fontSize).toFixed(1) + 'mm');
    gcode.push('; Position: X' + xOffsetMm.toFixed(1) + ' Y' + yOffsetMm.toFixed(1));
    gcode.push('; Dimensions: ' + widthMm.toFixed(1) + 'x' + heightMm.toFixed(1) + 'mm');
    gcode.push('');
    
    // For text, we'll create a simple outline engraving
    var laserPower = Math.round(LASER_CONFIG.maxPower * 0.7); // 70% power for text
    
    gcode.push('; Text outline engraving');
    gcode.push('G0 X' + xOffsetMm.toFixed(2) + ' Y' + yOffsetMm.toFixed(2) + ' ; Move to text start');
    gcode.push('M106 S' + laserPower + ' ; Set laser power to ' + Math.round((laserPower/255)*100) + '%');
    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Set engraving speed');
    
    // Create a simple rectangular outline for text (in a real implementation, you'd trace the actual font paths)
    gcode.push('G1 X' + (xOffsetMm + widthMm).toFixed(2) + ' ; Right edge');
    gcode.push('G1 Y' + (yOffsetMm + heightMm).toFixed(2) + ' ; Top edge');  
    gcode.push('G1 X' + xOffsetMm.toFixed(2) + ' ; Left edge');
    gcode.push('G1 Y' + yOffsetMm.toFixed(2) + ' ; Bottom edge');
    
    gcode.push(LASER_CONFIG.laserOff + ' ; Turn off laser');
    
    return gcode.join('\n');
}

/**
 * Export canvas content as G-code for laser engraving
 */
function downloadGcode() {
    // Check if there's anything on the canvas to export (excluding grid)
    var exportableObjects = canvas.getObjects().filter(function(obj) {
        return !obj.excludeFromExport;
    });

    if (exportableObjects.length === 0) {
        alert('Le canevas est vide. Ajoutez des objets avant d\'exporter.');
        return;
    }

    console.log('Generating G-code for the entire canvas as a single image...');

    var gcode = [];

    // Add header
    gcode.push(generateGcodeHeader());

    // Process the entire canvas as one image
    gcode.push('; Processing entire canvas as a single image');
    var canvasGcode = processCanvasToGcode(); // This function handles the whole canvas
    if (canvasGcode && canvasGcode.trim() !== '') {
        gcode.push(canvasGcode);
    } else {
        console.log('processCanvasToGcode returned empty or whitespace only G-code. This might happen if the canvas is effectively blank.');
        // Optionally, you could alert the user here or add a comment to the G-code file.
        gcode.push('; Warning: Canvas content resulted in empty G-code.');
    }
    gcode.push(''); // Add a blank line for separation

    // Add footer
    gcode.push(generateGcodeFooter());

    var finalGcode = gcode.join('\n');

    // Show preview of G-code
    console.log('Generated G-code:');
    console.log(finalGcode);

    // Create file and download
    var blob = new Blob([finalGcode], { type: 'text/plain' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    // Changed filename to reflect it's a full canvas export
    a.download = currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '_canvas.gcode';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Show success message
    alert('G-code g√©n√©r√© avec succ√®s pour l\'ensemble du canevas!\n\n' +
          'Fichier: ' + a.download + '\n\n' +
          'Configuration laser:\n' +
          '- Commande ON: M106 (contr√¥le du ventilateur)\n' +
          '- Commande OFF: M107\n' +
          '- Puissance max: ' + LASER_CONFIG.maxPower + ' (PWM)\n' +
          '- Vitesse gravure: ' + LASER_CONFIG.feedRate + ' mm/min\n' +
          '- Vitesse d√©placement: ' + LASER_CONFIG.travelRate + ' mm/min');
}

/**
 * Load machine profile configuration
 */
function loadMachineProfile(profileName) {
    if (LASER_CONFIG.machineProfiles[profileName]) {
        var profile = LASER_CONFIG.machineProfiles[profileName];
        
        // Update LASER_CONFIG with profile values
        LASER_CONFIG.maxPower = profile.maxPower;
        LASER_CONFIG.minPower = profile.minPower;
        LASER_CONFIG.feedRate = profile.feedRate;
        LASER_CONFIG.travelRate = profile.travelRate;
        LASER_CONFIG.laserOn = profile.laserOn;
        LASER_CONFIG.laserOff = profile.laserOff;
        LASER_CONFIG.powerCurve = profile.powerCurve;
        LASER_CONFIG.currentMachineProfile = profileName;
        
        // Update UI elements if they exist
        updateUIFromConfig();
        
        console.log('Machine profile loaded:', profile.name);
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'Profil machine charg√©: ' + profile.name;
            statusElement.style.color = '#28a745';
        }
        
        return true;
    }
    return false;
}

/**
 * Save current configuration as machine profile
 */
function saveMachineProfile(profileName, name) {
    LASER_CONFIG.machineProfiles[profileName] = {
        name: name,
        maxPower: LASER_CONFIG.maxPower,
        minPower: LASER_CONFIG.minPower,
        feedRate: LASER_CONFIG.feedRate,
        travelRate: LASER_CONFIG.travelRate,
        laserOn: LASER_CONFIG.laserOn,
        laserOff: LASER_CONFIG.laserOff,
        powerCurve: LASER_CONFIG.powerCurve
    };
    
    // Save to localStorage
    try {
        localStorage.setItem('laserMachineProfiles', JSON.stringify(LASER_CONFIG.machineProfiles));
        console.log('Machine profile saved:', name);
        return true;
    } catch (e) {
        console.error('Failed to save machine profile:', e);
        return false;
    }
}

/**
 * Load machine profiles from localStorage
 */
function loadMachineProfiles() {
    try {
        var saved = localStorage.getItem('laserMachineProfiles');
        if (saved) {
            var profiles = JSON.parse(saved);
            // Merge with default profiles
            LASER_CONFIG.machineProfiles = Object.assign(LASER_CONFIG.machineProfiles, profiles);
            console.log('Machine profiles loaded from storage');
        }
    } catch (e) {
        console.error('Failed to load machine profiles:', e);
    }
}

/**
 * Apply speed profile
 */
function applySpeedProfile(profileName) {
    if (LASER_CONFIG.speedProfiles[profileName]) {
        var profile = LASER_CONFIG.speedProfiles[profileName];
        LASER_CONFIG.feedRate = profile.feedRate;
        LASER_CONFIG.travelRate = profile.travelRate;
        LASER_CONFIG.currentSpeedProfile = profileName;
        
        updateUIFromConfig();
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'Profil vitesse appliqu√©: ' + profileName;
            statusElement.style.color = '#28a745';
        }
        
        console.log('Speed profile applied:', profileName, profile);
    }
}

/**
 * Apply resolution profile
 */
function applyResolutionProfile(profileName) {
    if (LASER_CONFIG.resolutionPresets[profileName]) {
        var preset = LASER_CONFIG.resolutionPresets[profileName];
        LASER_CONFIG.resolution = preset.resolution;
        LASER_CONFIG.currentResolutionProfile = profileName;
        
        updateUIFromConfig();
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'R√©solution appliqu√©e: ' + preset.description;
            statusElement.style.color = '#28a745';
        }
        
        console.log('Resolution profile applied:', profileName, preset);
    }
}

/**
 * Update UI elements from current configuration
 */
function updateUIFromConfig() {
    // Update basic laser settings
    var maxPowerInput = document.getElementById('maxPower');
    var minPowerInput = document.getElementById('minPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var resolutionInput = document.getElementById('resolution');
    var powerCurveSelect = document.getElementById('powerCurve');
    
    if (maxPowerInput) maxPowerInput.value = LASER_CONFIG.maxPower;
    if (minPowerInput) minPowerInput.value = LASER_CONFIG.minPower;
    if (feedRateInput) feedRateInput.value = LASER_CONFIG.feedRate;
    if (travelRateInput) travelRateInput.value = LASER_CONFIG.travelRate;
    if (resolutionInput) resolutionInput.value = LASER_CONFIG.resolution;
    if (powerCurveSelect) powerCurveSelect.value = LASER_CONFIG.powerCurve;
    
    // Update profile selectors
    var speedProfileSelect = document.getElementById('speedProfile');
    var resolutionProfileSelect = document.getElementById('resolutionProfile');
    var machineProfileSelect = document.getElementById('machineProfile');
    
    if (speedProfileSelect) speedProfileSelect.value = LASER_CONFIG.currentSpeedProfile;
    if (resolutionProfileSelect) resolutionProfileSelect.value = LASER_CONFIG.currentResolutionProfile;
    if (machineProfileSelect) machineProfileSelect.value = LASER_CONFIG.currentMachineProfile;
    
    // Update advanced settings
    var adaptivePowerCheckbox = document.getElementById('adaptivePower');
    var optimizeTravelCheckbox = document.getElementById('optimizeTravel');
    var bidirectionalScanCheckbox = document.getElementById('bidirectionalScan');
    
    if (adaptivePowerCheckbox) adaptivePowerCheckbox.checked = LASER_CONFIG.adaptivePower;
    if (optimizeTravelCheckbox) optimizeTravelCheckbox.checked = LASER_CONFIG.optimizeTravel;
    if (bidirectionalScanCheckbox) bidirectionalScanCheckbox.checked = LASER_CONFIG.bidirectionalScan;
}

/**
 * Enhanced laser configuration update function
 */
function updateLaserConfig() {
    // Basic settings
    var maxPowerInput = document.getElementById('maxPower');
    var minPowerInput = document.getElementById('minPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var resolutionInput = document.getElementById('resolution');
    var powerCurveSelect = document.getElementById('powerCurve');
    var statusElement = document.getElementById('laserStatus');
    
    // Update configuration
    if (maxPowerInput) LASER_CONFIG.maxPower = parseInt(maxPowerInput.value) || 255;
    if (minPowerInput) LASER_CONFIG.minPower = parseInt(minPowerInput.value) || 5;
    if (feedRateInput) LASER_CONFIG.feedRate = parseInt(feedRateInput.value) || 1000;
    if (travelRateInput) LASER_CONFIG.travelRate = parseInt(travelRateInput.value) || 3000;
    if (resolutionInput) LASER_CONFIG.resolution = parseInt(resolutionInput.value) || 10;
    if (powerCurveSelect) LASER_CONFIG.powerCurve = powerCurveSelect.value || 'linear';
    
    // Advanced settings
    var adaptivePowerCheckbox = document.getElementById('adaptivePower');
    var optimizeTravelCheckbox = document.getElementById('optimizeTravel');
    var bidirectionalScanCheckbox = document.getElementById('bidirectionalScan');
    var lightThresholdInput = document.getElementById('lightBurnThreshold');
    var deepThresholdInput = document.getElementById('burnDeepThreshold');
    
    if (adaptivePowerCheckbox) LASER_CONFIG.adaptivePower = adaptivePowerCheckbox.checked;
    if (optimizeTravelCheckbox) LASER_CONFIG.optimizeTravel = optimizeTravelCheckbox.checked;
    if (bidirectionalScanCheckbox) LASER_CONFIG.bidirectionalScan = bidirectionalScanCheckbox.checked;
    if (lightThresholdInput) LASER_CONFIG.lightBurnThreshold = parseInt(lightThresholdInput.value) || 50;
    if (deepThresholdInput) LASER_CONFIG.burnDeepThreshold = parseInt(deepThresholdInput.value) || 200;
    
    // Save configuration to localStorage
    try {
        localStorage.setItem('laserConfig', JSON.stringify(LASER_CONFIG));
    } catch (e) {
        console.error('Failed to save laser configuration:', e);
    }
    
    if (statusElement) {
        statusElement.textContent = `Configuration mise √† jour: ${LASER_CONFIG.maxPower}/${LASER_CONFIG.minPower} PWM, ${LASER_CONFIG.feedRate}/${LASER_CONFIG.travelRate} mm/min, ${LASER_CONFIG.resolution} px/mm`;
        statusElement.style.color = '#28a745';
        
        // Reset color after 3 seconds
        setTimeout(function() {
            if (statusElement) {
                statusElement.style.color = '#666';
            }
        }, 3000);
    }
    
    console.log('Enhanced laser config updated:', LASER_CONFIG);
}

/**
 * Initialize laser configuration system
 */
function initializeLaserConfig() {
    // Load saved configuration
    try {
        var saved = localStorage.getItem('laserConfig');
        if (saved) {
            var savedConfig = JSON.parse(saved);
            // Merge with default configuration, preserving structure
            Object.assign(LASER_CONFIG, savedConfig);
            console.log('Laser configuration loaded from storage');
        }
    } catch (e) {
        console.error('Failed to load laser configuration:', e);
    }
    
    // Load machine profiles
    loadMachineProfiles();
    
    // Update UI to reflect current configuration
    updateUIFromConfig();
    
    console.log('Laser configuration system initialized');
}

// Initialize on page load
if (typeof window !== 'undefined') {
    window.addEventListener('load', function() {
        setTimeout(initializeLaserConfig, 100); // Small delay to ensure DOM is ready
    });
}

/**
 * Debug function to save canvas as image (for development purposes)
 */
function debugSaveCanvasImage(canvas, filename) {
    // Only available in development mode - create a download link
    try {
        var link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL();
        
        // Temporarily add to document and click (simulate download)
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('Debug image saved:', filename);
    } catch (error) {
        console.log('Debug image save skipped (not in development mode):', filename);
    }
}

/**
 * Find the bounding box of content in image data
 * @param {Uint8ClampedArray} data - Image data
 * @param {number} width - Image width
 * @param {number} height - Image height
 * @param {number} threshold - Threshold for detecting content (0-255)
 * @returns {Object|null} Bounding box {x, y, width, height} or null if no content
 */
function findImageBoundsWithThreshold(data, width, height, threshold) {
    var minX = width, minY = height, maxX = 0, maxY = 0;
    var hasContent = false;
    
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pixelIndex = (y * width + x) * 4;
            var r = data[pixelIndex];
            var g = data[pixelIndex + 1];
            var b = data[pixelIndex + 2];
            var alpha = data[pixelIndex + 3];
            
            // Convert to grayscale
            var grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            
            // Check if pixel is not white/transparent (content)
            if (alpha > 0 && grayscale < threshold) {
                hasContent = true;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
    }
    
    if (!hasContent) {
        return null;
    }
    
    return {
        x: minX,
        y: minY,
        width: maxX - minX + 1,
        height: maxY - minY + 1
    };
}

/**
 * Crop image data to specified bounds
 * @param {Uint8ClampedArray} data - Original image data
 * @param {number} width - Original image width
 * @param {number} height - Original image height
 * @param {Object} bounds - Crop bounds {x, y, width, height}
 * @returns {Uint8ClampedArray} Cropped image data
 */
function cropImageData(data, width, height, bounds) {
    var croppedData = new Uint8ClampedArray(bounds.width * bounds.height * 4);
    
    for (var y = 0; y < bounds.height; y++) {
        for (var x = 0; x < bounds.width; x++) {
            var srcX = bounds.x + x;
            var srcY = bounds.y + y;
            
            // Ensure we don't go out of bounds
            if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                var srcIndex = (srcY * width + srcX) * 4;
                var destIndex = (y * bounds.width + x) * 4;
                
                croppedData[destIndex] = data[srcIndex];         // R
                croppedData[destIndex + 1] = data[srcIndex + 1]; // G
                croppedData[destIndex + 2] = data[srcIndex + 2]; // B
                croppedData[destIndex + 3] = data[srcIndex + 3]; // A
            }
        }
    }
    
    return croppedData;
}
