/**
 * Export Functionality Module
 * Handles G-code export for laser engraving on Ender 3
 */

// Simplified Laser Configuration - Only 3 main parameters
var LASER_CONFIG = {
    // === MAIN USER PARAMETERS ===
    precision: 10,        // Precision in pixels/mm (higher = more detailed)
    speed: 1000,         // Speed in mm/min (lower = slower, better quality) 
    power: 128,          // Max power 0-255 (lower = lighter engraving)
    
    // === AUTOMATIC QUALITY SETTINGS ===
    powerStabilizationDelay: 50,  // ms delay after power changes for machine stability
    minMovementDelay: 20,         // ms minimum delay between movements
    powerChangeThreshold: 10,     // minimum power change to trigger delay
    smoothPowerTransitions: true, // gradually change power instead of instant
    qualityMode: 'balanced',      // 'fast', 'balanced', 'quality'
    
    // === MACHINE SETTINGS (AUTO-CALCULATED) ===
    maxPower: 255,        // Maximum fan PWM value
    minPower: 5,          // Minimum power for light engraving
    travelRate: 3000,     // Auto-calculated based on speed
    laserOn: 'M106',      // Fan on command
    laserOff: 'M107',     // Fan off command
    units: 'G21',         // Millimeters
    positioning: 'G90',   // Absolute positioning
    
    // === QUALITY PRESETS ===
    qualityPresets: {
        'fast': {
            precision: 5,
            speed: 1500,
            powerStabilizationDelay: 25,
            minMovementDelay: 10,
            description: 'Gravure rapide - Qualit√© r√©duite'
        },
        'balanced': {
            precision: 10,
            speed: 1000,
            powerStabilizationDelay: 50,
            minMovementDelay: 20,
            description: '√âquilibr√© - Qualit√©/Vitesse'
        },
        'quality': {
            precision: 20,
            speed: 600,
            powerStabilizationDelay: 100,
            minMovementDelay: 40,
            description: 'Haute qualit√© - Plus lent'
        },
        'ultra': {
            precision: 40,
            speed: 400,
            powerStabilizationDelay: 150,
            minMovementDelay: 60,
            description: 'Ultra qualit√© - Tr√®s lent'
        }
    }
};

/**
 * Generate G-code header with simplified parameters
 */
function generateGcodeHeader() {
    // Auto-calculate travel rate based on speed
    LASER_CONFIG.travelRate = Math.min(LASER_CONFIG.speed * 3, 5000);
    
    var header = [
        '; Generated by Image to G-Code Converter - Quality Enhanced',
        '; For Ender 3 with laser engraving (fan-controlled)',
        '; Date: ' + new Date().toLocaleString(),
        '',
        '; === SIMPLIFIED CONFIGURATION ===',
        '; Precision: ' + LASER_CONFIG.precision + ' samples/mm (resolution control)',
        '; Speed: ' + LASER_CONFIG.speed + ' mm/min (engraving)',
        '; Max Power: ' + LASER_CONFIG.power + '/' + LASER_CONFIG.maxPower + ' PWM (' + Math.round((LASER_CONFIG.power/255)*100) + '%)',
        '; Quality Mode: ' + LASER_CONFIG.qualityMode,
        '; Power Stabilization: ' + LASER_CONFIG.powerStabilizationDelay + 'ms delay',
        '; Travel Speed: ' + LASER_CONFIG.travelRate + ' mm/min (auto)',
        '; NOTE: Physical size is constant, precision only affects sampling resolution',
        '',
        '; Initialize machine',
        LASER_CONFIG.units + ' ; Set units to millimeters',
        LASER_CONFIG.positioning + ' ; Absolute positioning',
        'G92 X0 Y0 Z0 ; Set current position as origin (0,0,0)',
        'F' + LASER_CONFIG.travelRate + ' ; Set travel feed rate',
        LASER_CONFIG.laserOff + ' ; Ensure laser is off',
        'G4 P500 ; Wait 500ms for machine stability',
        '',
        '; Begin quality engraving',
        ''
    ];
    return header.join('\n');
}

/**
 * Generate G-code footer
 */
function generateGcodeFooter() {
    var footer = [
        '',
        '; End engraving',
        LASER_CONFIG.laserOff + ' ; Turn off laser',
        'G0 X0 Y0 ; Return to origin',
        'M84 ; Disable steppers',
        '; End of G-code'
    ];
    return footer.join('\n');
}

/**
 * Convert grayscale value to laser power with quality enhancements
 * @param {number} grayscale - Grayscale value (0-255)
 * @returns {number} Laser power (0-255)
 */
function grayscaleToLaserPower(grayscale) {
    // Invert grayscale: darker = more power
    var inverted = 255 - grayscale;
    
    // More sensitive threshold - Skip only very light areas (< 3% intensity)
    // Lowered from 13 to 8 to catch more subtle dark areas
    if (inverted < 8) return 0;
    
    // Calculate normalized power (0-1)
    var normalizedPower = inverted / 255;
    
    // Apply gentle curve for better mid-tones
    normalizedPower = Math.pow(normalizedPower, 0.8);
    
    // Map to user's power range
    var laserPower = Math.round(normalizedPower * LASER_CONFIG.power);
    
    // Ensure minimum power for actual burning
    return Math.max(LASER_CONFIG.minPower, Math.min(LASER_CONFIG.power, laserPower));
}

/**
 * Fast nearest-neighbor sampling for G-code generation (PERFORMANCE OPTIMIZED)
 * @param {Uint8ClampedArray} data - Image data array
 * @param {number} width - Image width
 * @param {number} height - Image height
 * @param {number} x - X coordinate (can be fractional)
 * @param {number} y - Y coordinate (can be fractional)
 * @returns {Object} Nearest pixel RGBA values
 */
function getFastPixel(data, width, height, x, y) {
    // Use nearest-neighbor sampling for much better performance
    var px = Math.round(Math.max(0, Math.min(width - 1, x)));
    var py = Math.round(Math.max(0, Math.min(height - 1, y)));
    
    var index = (py * width + px) * 4;
    return {
        r: data[index] || 255,
        g: data[index + 1] || 255,
        b: data[index + 2] || 255,
        a: data[index + 3] || 255
    };
}

/**
 * Bilinear interpolation for resampling image data (ONLY for high-quality mode)
 * @param {Uint8ClampedArray} data - Image data array
 * @param {number} width - Image width
 * @param {number} height - Image height
 * @param {number} x - X coordinate (can be fractional)
 * @param {number} y - Y coordinate (can be fractional)
 * @returns {Object} Interpolated RGBA values
 */
function getInterpolatedPixel(data, width, height, x, y) {
    // For performance: Use fast sampling unless in ultra quality mode
    if (LASER_CONFIG.qualityMode !== 'ultra') {
        return getFastPixel(data, width, height, x, y);
    }
    
    // Full bilinear interpolation only for ultra quality mode
    x = Math.max(0, Math.min(width - 1, x));
    y = Math.max(0, Math.min(height - 1, y));
    
    var x1 = Math.floor(x);
    var y1 = Math.floor(y);
    var x2 = Math.min(x1 + 1, width - 1);
    var y2 = Math.min(y1 + 1, height - 1);
    
    var fx = x - x1;
    var fy = y - y1;
    
    // Get the four surrounding pixels
    var p1 = getPixel(data, width, x1, y1);
    var p2 = getPixel(data, width, x2, y1);
    var p3 = getPixel(data, width, x1, y2);
    var p4 = getPixel(data, width, x2, y2);
    
    // Bilinear interpolation
    var r = (1 - fx) * (1 - fy) * p1.r + fx * (1 - fy) * p2.r + (1 - fx) * fy * p3.r + fx * fy * p4.r;
    var g = (1 - fx) * (1 - fy) * p1.g + fx * (1 - fy) * p2.g + (1 - fx) * fy * p3.g + fx * fy * p4.g;
    var b = (1 - fx) * (1 - fy) * p1.b + fx * (1 - fy) * p2.b + (1 - fx) * fy * p3.b + fx * fy * p4.b;
    var a = (1 - fx) * (1 - fy) * p1.a + fx * (1 - fy) * p2.a + (1 - fx) * fy * p3.a + fx * fy * p4.a;
    
    return {
        r: Math.round(r),
        g: Math.round(g),
        b: Math.round(b),
        a: Math.round(a)
    };
}

/**
 * Get pixel data at specific coordinates
 * @param {Uint8ClampedArray} data - Image data array
 * @param {number} width - Image width
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @returns {Object} RGBA values
 */
function getPixel(data, width, x, y) {
    var index = (y * width + x) * 4;
    return {
        r: data[index] || 255,
        g: data[index + 1] || 255,
        b: data[index + 2] || 255,
        a: data[index + 3] || 255
    };
}

/**
 * Generate G-code with power stabilization and quality improvements
 * @param {number} newPower - New laser power
 * @param {number} currentPower - Current laser power
 * @param {number} x - X position
 * @param {number} y - Y position (optional)
 * @returns {Array} Array of G-code commands
 */
function generateQualityPowerChange(newPower, currentPower, x, y) {
    var gcode = [];
    
    // If power is the same, no change needed
    if (newPower === currentPower) {
        return gcode;
    }
    
    // Calculate power difference
    var powerDiff = Math.abs(newPower - currentPower);
    var needsStabilization = powerDiff >= LASER_CONFIG.powerChangeThreshold;
    
    if (newPower === 0) {
        // Turning laser off
        gcode.push(LASER_CONFIG.laserOff + ' ; Laser OFF');
        if (needsStabilization) {
            gcode.push('G4 P' + LASER_CONFIG.powerStabilizationDelay + ' ; Stabilization delay');
        }
    } else if (currentPower === 0) {
        // Turning laser on from off
        gcode.push('F' + LASER_CONFIG.speed + ' ; Set engraving speed');
        gcode.push(LASER_CONFIG.laserOn + ' S' + newPower + ' ; Laser ON at ' + Math.round((newPower/255)*100) + '%');
        if (needsStabilization) {
            gcode.push('G4 P' + LASER_CONFIG.powerStabilizationDelay + ' ; Power stabilization');
        }
        if (x !== undefined) {
            if (y !== undefined) {
                gcode.push('G1 X' + x.toFixed(3) + ' Y' + y.toFixed(3) + ' ; Start burn');
            } else {
                gcode.push('G1 X' + x.toFixed(3) + ' ; Start burn');
            }
        }
    } else {
        // Changing power level
        if (LASER_CONFIG.smoothPowerTransitions && powerDiff > 20) {
            // Smooth transition for large power changes
            var steps = Math.ceil(powerDiff / 20);
            var stepSize = (newPower - currentPower) / steps;
            
            for (var i = 1; i <= steps; i++) {
                var intermediePower = Math.round(currentPower + (stepSize * i));
                gcode.push(LASER_CONFIG.laserOn + ' S' + intermediePower + ' ; Smooth transition');
                if (i < steps) {
                    gcode.push('G4 P' + Math.round(LASER_CONFIG.minMovementDelay / steps) + ' ; Transition delay');
                }
            }
        } else {
            // Direct power change
            gcode.push(LASER_CONFIG.laserOn + ' S' + newPower + ' ; Power ' + Math.round((newPower/255)*100) + '%');
        }
        
        if (needsStabilization) {
            gcode.push('G4 P' + LASER_CONFIG.minMovementDelay + ' ; Movement delay');
        }
    }
    
    return gcode;
}

/**
 * Convert canvas to image data (without grid) and generate G-code ASYNC
 */
function processCanvasToGcodeAsync(callback) {
    console.log('Converting canvas to image for laser engraving (async)...');
    
    // Temporarily hide grid elements completely (remove from canvas)
    var gridElements = canvas.getObjects().filter(function(obj) {
        return obj.excludeFromExport;
    });
    
    console.log('Removing', gridElements.length, 'grid elements temporarily');
    gridElements.forEach(function(obj) {
        canvas.remove(obj);
    });
    
    canvas.renderAll();
    
    setTimeout(function() {
        if (gcodeGenerationCancelled) return;
        
        // For debugging, let's try extracting the entire canvas first (without grid)
        var fabricCanvasElement = canvas.getElement();
        console.log('Fabric canvas element size:', fabricCanvasElement.width, 'x', fabricCanvasElement.height);
        
        // Check if there are any content objects and their positions
        var objects = canvas.getObjects(); // All remaining objects (no grid)
        console.log('Content objects on canvas:', objects.length);
        
        if (objects.length === 0) {
            console.log('No content objects found after grid removal');
            // Restore grid elements
            gridElements.forEach(function(obj) {
                canvas.add(obj);
            });
            canvas.renderAll();
            callback('', 100, 'Aucun contenu trouv√©');
            return;
        }
        
        callback(null, 10, 'Extraction de l\'image...');
        
        setTimeout(function() {
            if (gcodeGenerationCancelled) return;
            
            // Use the full canvas approach since it's simpler and more reliable
            var fullCanvas = document.createElement('canvas');
            var fullCtx = fullCanvas.getContext('2d');
            fullCanvas.width = fabricCanvasElement.width;
            fullCanvas.height = fabricCanvasElement.height;
            
            // Fill with white background
            fullCtx.fillStyle = 'white';
            fullCtx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
            
            // Draw the clean canvas content
            fullCtx.drawImage(fabricCanvasElement, 0, 0);
            
            // Get image data from full canvas
            var fullImageData = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);
            var data = fullImageData.data;
            
            callback(null, 20, 'Analyse du contenu...');
            
            setTimeout(function() {
                if (gcodeGenerationCancelled) return;
                
                // Find bounding box of content
                var bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 200);
                
                if (!bounds) {
                    bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 100);
                }
                
                if (!bounds) {
                    bounds = { x: 0, y: 0, width: fullCanvas.width, height: fullCanvas.height };
                }
                
                console.log('Content bounds found:', bounds);
                
                // Crop the content
                var croppedData = cropImageData(data, fullCanvas.width, fullCanvas.height, bounds);
                var croppedWidth = bounds.width;
                var croppedHeight = bounds.height;
                
                callback(null, 30, 'Calcul des dimensions...');
                
                setTimeout(function() {
                    if (gcodeGenerationCancelled) return;
                    
                    processImageDataAsync(croppedData, croppedWidth, croppedHeight, gridElements, callback);
                }, 50);
            }, 50);
        }, 50);
    }, 50);
}

/**
 * Process image data to G-code asynchronously (PERFORMANCE OPTIMIZED)
 */
function processImageDataAsync(croppedData, croppedWidth, croppedHeight, gridElements, callback) {
    // The cropped dimensions are in canvas pixels. We need to convert them to physical mm
    // Since the canvas represents the full fabricjs canvas, we need to use the fabricjs canvas scale
    
    // Get the fabric canvas scale - it converts canvas pixels to workspace coordinates
    var fabricCanvas = canvas.getElement();
    var canvasScaleX = fabricCanvas.width / canvas.width;
    var canvasScaleY = fabricCanvas.height / canvas.height;
    
    // Convert cropped pixels to fabric canvas coordinates
    var fabricWidthPixels = croppedWidth / canvasScaleX;
    var fabricHeightPixels = croppedHeight / canvasScaleY;
    
    // Now convert fabric canvas coordinates to physical millimeters using workspace scale
    var croppedWidthMm = WORKSPACE_CONFIG.pixelsToMm(fabricWidthPixels);
    var croppedHeightMm = WORKSPACE_CONFIG.pixelsToMm(fabricHeightPixels);
    
    // Calculate sampling resolution based on precision setting
    var resolution = LASER_CONFIG.precision;
    var sampleSpacing = 1 / resolution;
    
    // Calculate how many samples we need for the actual dimensions
    var samplesWidth = Math.ceil(croppedWidthMm * resolution);
    var samplesHeight = Math.ceil(croppedHeightMm * resolution);
    
    console.log(`Canvas scaling: ${canvasScaleX.toFixed(2)}x${canvasScaleY.toFixed(2)}`);
    console.log(`Cropped pixels: ${croppedWidth}x${croppedHeight}`);
    console.log(`Fabric pixels: ${fabricWidthPixels.toFixed(1)}x${fabricHeightPixels.toFixed(1)}`);
    console.log(`Final dimensions: ${croppedWidthMm.toFixed(2)}x${croppedHeightMm.toFixed(2)}mm (actual size)`);
    console.log(`Resampled to: ${samplesWidth}x${samplesHeight} samples (${resolution.toFixed(2)} samples/mm)`);
    console.log(`Performance mode: ${LASER_CONFIG.qualityMode} (${LASER_CONFIG.qualityMode === 'ultra' ? 'bilinear' : 'nearest-neighbor'} sampling)`);
    
    // Pre-analyze empty rows for super-fast skipping (performance optimization)
    var nonEmptyRows = [];
    var emptyRowCount = 0;
    
    callback(null, 30, 'Pr√©-analyse des lignes...', 'Optimisation des performances');
    
    setTimeout(function() {
        if (gcodeGenerationCancelled) return;
        
        // Quick scan for content rows with improved detection
        for (var sampleY = 0; sampleY < samplesHeight; sampleY++) {
            var hasContent = false;
            
            // Improved content detection: Sample every 2nd pixel instead of every 4th
            // This significantly reduces the chance of missing thin black lines or small dark areas
            var sampleStep = Math.max(1, Math.floor(samplesWidth / 50)); // Adaptive sampling based on width
            
            for (var sampleX = 0; sampleX < samplesWidth; sampleX += sampleStep) {
                var sourceX = (sampleX / samplesWidth) * croppedWidth;
                var sourceY = (sampleY / samplesHeight) * croppedHeight;
                
                var pixel = getFastPixel(croppedData, croppedWidth, croppedHeight, sourceX, sourceY);
                var grayscale = Math.round(0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b);
                
                if (grayscaleToLaserPower(grayscale) > 0) {
                    hasContent = true;
                    break;
                }
            }
            
            // Additional check for very thin features: Sample at different offsets
            if (!hasContent && samplesWidth > 20) {
                var offset = Math.floor(sampleStep / 2);
                for (var sampleX = offset; sampleX < samplesWidth; sampleX += sampleStep) {
                    var sourceX = (sampleX / samplesWidth) * croppedWidth;
                    var sourceY = (sampleY / samplesHeight) * croppedHeight;
                    
                    var pixel = getFastPixel(croppedData, croppedWidth, croppedHeight, sourceX, sourceY);
                    var grayscale = Math.round(0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b);
                    
                    if (grayscaleToLaserPower(grayscale) > 0) {
                        hasContent = true;
                        break;
                    }
                }
            }
            
            if (hasContent) {
                nonEmptyRows.push(sampleY);
            } else {
                emptyRowCount++;
            }
        }
        
        console.log(`Performance optimization: ${emptyRowCount} empty rows skipped, ${nonEmptyRows.length} content rows to process`);
        
        // Generate G-code header
        var gcode = [];
        gcode.push('; Quality raster engraving: ' + croppedWidthMm.toFixed(2) + 'x' + croppedHeightMm.toFixed(2) + 'mm');
        gcode.push('; Physical size: ' + croppedWidthMm.toFixed(2) + 'x' + croppedHeightMm.toFixed(2) + 'mm (workspace scale)');
        gcode.push('; Sampling: ' + resolution.toFixed(2) + ' samples/mm (' + sampleSpacing.toFixed(3) + 'mm spacing)');
        gcode.push('; Resampled: ' + samplesWidth + 'x' + samplesHeight + ' samples from ' + croppedWidth + 'x' + croppedHeight + ' pixels');
        gcode.push('; Speed: ' + LASER_CONFIG.speed + ' mm/min, Max Power: ' + LASER_CONFIG.power + '/' + LASER_CONFIG.maxPower);
        gcode.push('; Quality Mode: ' + LASER_CONFIG.qualityMode + ', Stabilization: ' + LASER_CONFIG.powerStabilizationDelay + 'ms');
        gcode.push('; Performance: ' + emptyRowCount + ' empty rows skipped, ' + (LASER_CONFIG.qualityMode === 'ultra' ? 'bilinear' : 'nearest-neighbor') + ' sampling');
        gcode.push('; Bidirectional scanning: ENABLED (zigzag pattern - optimized movement)');
        gcode.push('; Movement optimization: Direct positioning to first engrave point per row');
        gcode.push('; White space fix: Improved content detection and conservative gap skipping');
        gcode.push('; Scan pattern: Row 0,2,4... = Left-to-Right, Row 1,3,5... = Right-to-Left');
        gcode.push('');
        
        var currentLaserPower = 0;
        var totalRows = nonEmptyRows.length; // Only count non-empty rows
        var processedRows = 0;
        
        callback(null, 40, 'G√©n√©ration optimis√©e...', `0/${totalRows} lignes avec contenu`);
        
        // Process only non-empty rows for much better performance
        processOptimizedRowsAsync(gcode, croppedData, croppedWidth, croppedHeight, samplesWidth, samplesHeight, 
                                 sampleSpacing, resolution, currentLaserPower, processedRows, nonEmptyRows, gridElements, callback);
    }, 50);
}

/**
 * Process rows asynchronously with yield points (PERFORMANCE OPTIMIZED)
 */
function processRowsAsync(gcode, croppedData, croppedWidth, croppedHeight, samplesWidth, samplesHeight, 
                         sampleSpacing, resolution, currentLaserPower, processedRows, totalRows, gridElements, callback) {
    
    // Dynamic batch size based on quality mode for better performance
    var BATCH_SIZE = LASER_CONFIG.qualityMode === 'fast' ? 20 : 
                     LASER_CONFIG.qualityMode === 'balanced' ? 10 : 
                     LASER_CONFIG.qualityMode === 'quality' ? 5 : 3; // ultra quality
    
    // For ultra quality, use smaller batches but better interpolation
    var yieldTime = LASER_CONFIG.qualityMode === 'fast' ? 5 : 10;
    
    var startRow = totalRows - 1 - processedRows;
    var endRow = Math.max(startRow - BATCH_SIZE + 1, 0);
    
    // Pre-compute row data for entire batch to optimize processing
    var batchRowData = [];
    
    for (var sampleY = startRow; sampleY >= endRow; sampleY--) {
        if (gcodeGenerationCancelled) return;
        
        var yPosMm = (samplesHeight - 1 - sampleY) * sampleSpacing;
        var isRightToLeft = (processedRows % 2 === 1);
        var rowData = [];
        var rowHasContent = false;
        
        // Fast pre-scan the row using optimized sampling
        for (var sampleX = 0; sampleX < samplesWidth; sampleX++) {
            var sourceX = (sampleX / samplesWidth) * croppedWidth;
            var sourceY = (sampleY / samplesHeight) * croppedHeight;
            
            // Use optimized pixel sampling
            var pixel = getInterpolatedPixel(croppedData, croppedWidth, croppedHeight, sourceX, sourceY);
            var grayscale = Math.round(0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b);
            var laserPower = grayscaleToLaserPower(grayscale);
            
            rowData.push({
                x: sampleX,
                power: laserPower,
                grayscale: grayscale
            });
            
            if (laserPower > 0) {
                rowHasContent = true;
            }
        }
        
        if (rowHasContent) {
            // Reverse row data for right-to-left scanning
            if (isRightToLeft) {
                rowData.reverse();
                for (var r = 0; r < rowData.length; r++) {
                    rowData[r].x = samplesWidth - 1 - rowData[r].x;
                }
            }
            
            batchRowData.push({
                yPosMm: yPosMm,
                isRightToLeft: isRightToLeft,
                rowData: rowData,
                rowNumber: processedRows
            });
        }
        
        processedRows++;
    }
    
    // Process the batch row data into G-code
    for (var b = 0; b < batchRowData.length; b++) {
        var batchRow = batchRowData[b];
        
        // OPTIMIZED: Find first engraving position and move directly there
        var scanDirection = batchRow.isRightToLeft ? 'R-L' : 'L-R';
        
        // Find the first pixel that needs engraving in this row
        var firstEngravingX = -1;
        for (var i = 0; i < batchRow.rowData.length; i++) {
            if (batchRow.rowData[i].power > 0) {
                firstEngravingX = batchRow.rowData[i].x * sampleSpacing;
                break;
            }
        }
        
        // Move directly to the first engraving position (or skip row if no engraving needed)
        if (firstEngravingX >= 0) {
            gcode.push('G0 X' + firstEngravingX.toFixed(3) + ' Y' + batchRow.yPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + 
                      ' ; Row ' + batchRow.rowNumber + ' ' + scanDirection + ' - Direct to first engrave');
        } else {
            // Row has no engraving content, just move Y (shouldn't happen with optimized processing)
            gcode.push('G0 Y' + batchRow.yPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + ' ; Row ' + batchRow.rowNumber + ' - No content');
        }
        
        // Process pixels in this row with improved gap skipping
        var isLaserOn = false;
        // More conservative gap skipping to avoid missing content
        // Reduced threshold to be less aggressive, especially for high precision
        var skipThreshold = Math.max(3, Math.ceil(1.5 * resolution)); // More conservative threshold
        
        for (var i = 0; i < batchRow.rowData.length; i++) {
            var sample = batchRow.rowData[i];
            var xPosMm = sample.x * sampleSpacing;
            
            if (sample.power > 0) {
                var powerCommands = generateQualityPowerChange(sample.power, currentLaserPower, xPosMm);
                gcode = gcode.concat(powerCommands);
                currentLaserPower = sample.power;
                isLaserOn = true;
                gcode.push('G1 X' + xPosMm.toFixed(3) + ' ; Engrave');
            } else {
                if (isLaserOn) {
                    var offCommands = generateQualityPowerChange(0, currentLaserPower);
                    gcode = gcode.concat(offCommands);
                    currentLaserPower = 0;
                    isLaserOn = false;
                }
                
                // Optimized gap skipping - look ahead for content
                var nextContentIndex = -1;
                for (var j = i + 1; j < batchRow.rowData.length; j++) {
                    if (batchRow.rowData[j].power > 0) {
                        nextContentIndex = j;
                        break;
                    }
                }
                
                if (nextContentIndex > -1 && nextContentIndex - i > skipThreshold) {
                    var nextXPosMm = batchRow.rowData[nextContentIndex].x * sampleSpacing;
                    gcode.push('G0 X' + nextXPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + ' ; Skip gap');
                    i = nextContentIndex - 1; // -1 because loop will increment
                }
            }
        }
        
        // Ensure laser is off at end of row
        if (isLaserOn) {
            var endCommands = generateQualityPowerChange(0, currentLaserPower);
            gcode = gcode.concat(endCommands);
            currentLaserPower = 0;
        }
        
        // Add progress markers for user feedback
        if (batchRow.rowNumber % 10 === 0) {
            var progress = Math.round((batchRow.rowNumber / totalRows) * 100);
            gcode.push('; Progress: ' + progress + '% (' + batchRow.rowNumber + '/' + totalRows + ' rows)');
        }
    }
    
    // Update progress
    var progress = Math.round((processedRows / totalRows) * 100);
    callback(null, 40 + (progress * 0.5), 'Traitement...', `${processedRows}/${totalRows} lignes (${progress}%)`);
    
    if (processedRows < totalRows) {
        // Continue with next batch with optimized yield time
        setTimeout(function() {
            if (gcodeGenerationCancelled) return;
            processRowsAsync(gcode, croppedData, croppedWidth, croppedHeight, samplesWidth, samplesHeight, 
                           sampleSpacing, resolution, currentLaserPower, processedRows, totalRows, gridElements, callback);
        }, yieldTime); // Optimized yield time based on quality mode
    } else {
        // Processing complete - restore grid and return result
        console.log('Restoring', gridElements.length, 'grid elements');
        gridElements.forEach(function(obj) {
            canvas.add(obj);
        });
        canvas.renderAll();
        
        callback(gcode.join('\n'));
    }
}

/**
 * Process only non-empty rows asynchronously with yield points (PERFORMANCE OPTIMIZED)
 * This function processes only pre-analyzed rows that contain content, skipping completely empty rows
 */
function processOptimizedRowsAsync(gcode, croppedData, croppedWidth, croppedHeight, samplesWidth, samplesHeight, 
                                  sampleSpacing, resolution, currentLaserPower, processedRows, nonEmptyRows, gridElements, callback) {
    
    // Dynamic batch size based on quality mode for better performance
    var BATCH_SIZE = LASER_CONFIG.qualityMode === 'fast' ? 20 : 
                     LASER_CONFIG.qualityMode === 'balanced' ? 10 : 
                     LASER_CONFIG.qualityMode === 'quality' ? 5 : 3; // ultra quality
    
    // For ultra quality, use smaller batches but better interpolation
    var yieldTime = LASER_CONFIG.qualityMode === 'fast' ? 5 : 10;
    var totalRows = nonEmptyRows.length;
    
    var startIndex = processedRows;
    var endIndex = Math.min(startIndex + BATCH_SIZE, totalRows);
    
    // Pre-compute row data for entire batch to optimize processing
    var batchRowData = [];
    
    for (var i = startIndex; i < endIndex; i++) {
        if (gcodeGenerationCancelled) return;
        
        var sampleY = nonEmptyRows[i];  // Get the actual row index from non-empty rows array
        var yPosMm = (samplesHeight - 1 - sampleY) * sampleSpacing;
        var isRightToLeft = (i % 2 === 1);  // Use processed row count for bidirectional pattern
        var rowData = [];
        var rowHasContent = false;
        
        // Process all pixels in this row (we know it has content)
        for (var sampleX = 0; sampleX < samplesWidth; sampleX++) {
            var sourceX = (sampleX / samplesWidth) * croppedWidth;
            var sourceY = (sampleY / samplesHeight) * croppedHeight;
            
            // Use optimized pixel sampling based on quality mode
            var pixel;
            if (LASER_CONFIG.qualityMode === 'ultra') {
                pixel = getInterpolatedPixel(croppedData, croppedWidth, croppedHeight, sourceX, sourceY);
            } else {
                pixel = getFastPixel(croppedData, croppedWidth, croppedHeight, sourceX, sourceY);
            }
            
            var grayscale = Math.round(0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b);
            var laserPower = grayscaleToLaserPower(grayscale);
            
            rowData.push({
                x: sampleX,
                power: laserPower,
                grayscale: grayscale
            });
            
            if (laserPower > 0) {
                rowHasContent = true;
            }
        }
        
        if (rowHasContent) {
            // Reverse row data for right-to-left scanning (bidirectional)
            if (isRightToLeft) {
                rowData.reverse();
                for (var r = 0; r < rowData.length; r++) {
                    rowData[r].x = samplesWidth - 1 - rowData[r].x;
                }
            }
            
            batchRowData.push({
                yPosMm: yPosMm,
                isRightToLeft: isRightToLeft,
                rowData: rowData,
                rowNumber: i,
                actualRowIndex: sampleY
            });
        }
    }
    
    // Process the batch row data into G-code
    for (var b = 0; b < batchRowData.length; b++) {
        var batchRow = batchRowData[b];
        
        // OPTIMIZED: Find first engraving position and move directly there
        var scanDirection = batchRow.isRightToLeft ? 'R-L' : 'L-R';
        
        // Find the first pixel that needs engraving in this row
        var firstEngravingX = -1;
        for (var i = 0; i < batchRow.rowData.length; i++) {
            if (batchRow.rowData[i].power > 0) {
                firstEngravingX = batchRow.rowData[i].x * sampleSpacing;
                break;
            }
        }
        
        // Move directly to the first engraving position (or skip row if no engraving needed)
        if (firstEngravingX >= 0) {
            gcode.push('G0 X' + firstEngravingX.toFixed(3) + ' Y' + batchRow.yPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + 
                      ' ; Row ' + batchRow.actualRowIndex + ' (' + batchRow.rowNumber + '/' + totalRows + ') ' + scanDirection + ' - Direct to first engrave');
        } else {
            // Row has no engraving content, just move Y (shouldn't happen with optimized processing)
            gcode.push('G0 Y' + batchRow.yPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + ' ; Row ' + batchRow.actualRowIndex + ' - No content');
        }
        
        // Process pixels in this row with improved gap skipping
        var isLaserOn = false;
        // More conservative gap skipping to avoid missing content
        // Reduced threshold to be less aggressive, especially for high precision
        var skipThreshold = Math.max(3, Math.ceil(1.5 * resolution)); // More conservative threshold
        
        for (var i = 0; i < batchRow.rowData.length; i++) {
            var sample = batchRow.rowData[i];
            var xPosMm = sample.x * sampleSpacing;
            
            if (sample.power > 0) {
                // Turn laser on with optimized power commands
                var powerCommands = generateQualityPowerChange(sample.power, currentLaserPower, xPosMm);
                gcode = gcode.concat(powerCommands);
                currentLaserPower = sample.power;
                isLaserOn = true;
                gcode.push('G1 X' + xPosMm.toFixed(3) + ' ; Engrave');
            } else {
                if (isLaserOn) {
                    var offCommands = generateQualityPowerChange(0, currentLaserPower);
                    gcode = gcode.concat(offCommands);
                    currentLaserPower = 0;
                    isLaserOn = false;
                }
                
                // Optimized gap skipping - look ahead for content
                var nextContentIndex = -1;
                for (var j = i + 1; j < batchRow.rowData.length; j++) {
                    if (batchRow.rowData[j].power > 0) {
                        nextContentIndex = j;
                        break;
                    }
                }
                
                if (nextContentIndex > -1 && nextContentIndex - i > skipThreshold) {
                    var nextXPosMm = batchRow.rowData[nextContentIndex].x * sampleSpacing;
                    gcode.push('G0 X' + nextXPosMm.toFixed(3) + ' F' + LASER_CONFIG.travelRate + ' ; Skip gap');
                    i = nextContentIndex - 1; // -1 because loop will increment
                }
            }
        }
        
        // Ensure laser is off at end of row
        if (isLaserOn) {
            var endCommands = generateQualityPowerChange(0, currentLaserPower);
            gcode = gcode.concat(endCommands);
            currentLaserPower = 0;
        }
        
        // Add progress markers for user feedback
        if (batchRow.rowNumber % 10 === 0) {
            var progress = Math.round((batchRow.rowNumber / totalRows) * 100);
            gcode.push('; Progress: ' + progress + '% (' + batchRow.rowNumber + '/' + totalRows + ' content rows)');
        }
    }
    
    // Update processed row count
    processedRows = endIndex;
    
    // Update progress
    var progress = Math.round((processedRows / totalRows) * 100);
    callback(null, 40 + (progress * 0.5), 'Optimisation...', `${processedRows}/${totalRows} lignes avec contenu (${progress}%)`);
    
    if (processedRows < totalRows) {
        // Continue with next batch with optimized yield time
        setTimeout(function() {
            if (gcodeGenerationCancelled) return;
            processOptimizedRowsAsync(gcode, croppedData, croppedWidth, croppedHeight, samplesWidth, samplesHeight, 
                                    sampleSpacing, resolution, currentLaserPower, processedRows, nonEmptyRows, gridElements, callback);
        }, yieldTime); // Optimized yield time based on quality mode
    } else {
        // Processing complete - restore grid and return result
        console.log('Restoring', gridElements.length, 'grid elements');
        gridElements.forEach(function(obj) {
            canvas.add(obj);
        });
        canvas.renderAll();
        
        callback(gcode.join('\n'));
    }
}

/**
 * Process text object and generate G-code for vector engraving
 */
function processTextToGcode(textObj) {
    console.log('Processing text for laser engraving...');
    
    var bounds = textObj.getBoundingRect();
    var xOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.left - WORKSPACE_CONFIG.usableArea.offsetX);
    var yOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.top - WORKSPACE_CONFIG.usableArea.offsetY);
    var widthMm = WORKSPACE_CONFIG.pixelsToMm(bounds.width);
    var heightMm = WORKSPACE_CONFIG.pixelsToMm(bounds.height);
    
    var gcode = [];
    gcode.push('; Vector text engraving: "' + textObj.text + '"');
    gcode.push('; Font: ' + textObj.fontFamily + ', Size: ' + WORKSPACE_CONFIG.pixelsToMm(textObj.fontSize).toFixed(1) + 'mm');
    gcode.push('; Position: X' + xOffsetMm.toFixed(1) + ' Y' + yOffsetMm.toFixed(1));
    gcode.push('; Dimensions: ' + widthMm.toFixed(1) + 'x' + heightMm.toFixed(1) + 'mm');
    gcode.push('');
    
    // For text, we'll create a simple outline engraving
    var laserPower = Math.round(LASER_CONFIG.maxPower * 0.7); // 70% power for text
    
    gcode.push('; Text outline engraving');
    gcode.push('G0 X' + xOffsetMm.toFixed(2) + ' Y' + yOffsetMm.toFixed(2) + ' ; Move to text start');
    gcode.push('M106 S' + laserPower + ' ; Set laser power to ' + Math.round((laserPower/255)*100) + '%');
    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Set engraving speed');
    
    // Create a simple rectangular outline for text (in a real implementation, you'd trace the actual font paths)
    gcode.push('G1 X' + (xOffsetMm + widthMm).toFixed(2) + ' ; Right edge');
    gcode.push('G1 Y' + (yOffsetMm + heightMm).toFixed(2) + ' ; Top edge');  
    gcode.push('G1 X' + xOffsetMm.toFixed(2) + ' ; Left edge');
    gcode.push('G1 Y' + yOffsetMm.toFixed(2) + ' ; Bottom edge');
    
    gcode.push(LASER_CONFIG.laserOff + ' ; Turn off laser');
    
    return gcode.join('\n');
}

/**
 * Export canvas content as G-code for laser engraving (ASYNC with progress)
 */
function downloadGcode() {
    // Check if there's anything on the canvas to export (excluding grid)
    var exportableObjects = canvas.getObjects().filter(function(obj) {
        return !obj.excludeFromExport;
    });

    if (exportableObjects.length === 0) {
        alert('Le canevas est vide. Ajoutez des objets avant d\'exporter.');
        return;
    }

    console.log('Starting async G-code generation...');
    
    // Show progress modal
    showProgressModal();
    updateProgress(0, 'Initialisation...');
    
    // Start async processing
    setTimeout(function() {
        generateGcodeAsync();
    }, 100);
}

/**
 * Show progress modal dialog
 */
function showProgressModal() {
    // Remove any existing modal
    var existingModal = document.getElementById('gcodeProgressModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    var modal = document.createElement('div');
    modal.id = 'gcodeProgressModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: Arial, sans-serif;
    `;
    
    var content = document.createElement('div');
    content.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        min-width: 400px;
        max-width: 500px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    `;
    
    content.innerHTML = `
        <h3 style="margin-top: 0; color: #333;">üéØ G√©n√©ration G-code</h3>
        <div style="margin: 20px 0;">
            <div id="progressBar" style="
                width: 100%;
                height: 20px;
                background: #f0f0f0;
                border-radius: 10px;
                overflow: hidden;
                margin-bottom: 10px;
            ">
                <div id="progressFill" style="
                    width: 0%;
                    height: 100%;
                    background: linear-gradient(90deg, #4CAF50, #45a049);
                    transition: width 0.3s ease;
                "></div>
            </div>
            <div id="progressText" style="color: #666; font-size: 14px;">Initialisation...</div>
            <div id="progressDetails" style="color: #999; font-size: 12px; margin-top: 5px;"></div>
        </div>
        <button id="cancelGcode" style="
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
        ">Annuler</button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Handle cancel button
    document.getElementById('cancelGcode').onclick = function() {
        cancelGcodeGeneration();
    };
}

/**
 * Update progress display
 */
function updateProgress(percent, message, details) {
    var progressFill = document.getElementById('progressFill');
    var progressText = document.getElementById('progressText');
    var progressDetails = document.getElementById('progressDetails');
    
    if (progressFill) progressFill.style.width = percent + '%';
    if (progressText) progressText.textContent = message;
    if (progressDetails && details) progressDetails.textContent = details;
}

/**
 * Hide progress modal
 */
function hideProgressModal() {
    var modal = document.getElementById('gcodeProgressModal');
    if (modal) {
        modal.remove();
    }
}

/**
 * Cancel G-code generation
 */
var gcodeGenerationCancelled = false;
function cancelGcodeGeneration() {
    gcodeGenerationCancelled = true;
    hideProgressModal();
    console.log('G-code generation cancelled by user');
}

/**
 * Async G-code generation with progress feedback
 */
function generateGcodeAsync() {
    gcodeGenerationCancelled = false;
    
    updateProgress(10, 'Pr√©paration du canvas...');
    
    setTimeout(function() {
        if (gcodeGenerationCancelled) return;
        
        var gcode = [];
        
        // Add header
        gcode.push(generateGcodeHeader());
        updateProgress(20, 'En-t√™te G-code g√©n√©r√©...');
        
        setTimeout(function() {
            if (gcodeGenerationCancelled) return;
            
            // Process the entire canvas as one image
            gcode.push('; Processing entire canvas as a single image');
            updateProgress(30, 'Traitement de l\'image...', 'Extraction et analyse du contenu');
            
            // Process canvas with progress callback
            processCanvasToGcodeAsync(function(canvasGcode, progress, message) {
                if (gcodeGenerationCancelled) return;
                
                if (progress !== undefined) {
                    updateProgress(30 + (progress * 0.6), message || 'G√©n√©ration G-code...');
                    return;
                }
                
                // Processing complete
                if (canvasGcode && canvasGcode.trim() !== '') {
                    gcode.push(canvasGcode);
                } else {
                    console.log('processCanvasToGcode returned empty G-code');
                    gcode.push('; Warning: Canvas content resulted in empty G-code.');
                }
                gcode.push('');
                
                updateProgress(95, 'Finalisation...');
                
                setTimeout(function() {
                    if (gcodeGenerationCancelled) return;
                    
                    // Add footer
                    gcode.push(generateGcodeFooter());
                    
                    var finalGcode = gcode.join('\n');
                    
                    // Create file and download
                    var blob = new Blob([finalGcode], { type: 'text/plain' });
                    var url = URL.createObjectURL(blob);
                    var a = document.createElement('a');
                    a.href = url;
                    a.download = currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '_canvas.gcode';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    updateProgress(100, 'Termin√©!');
                    
                    setTimeout(function() {
                        hideProgressModal();
                        
                        // Show success message
                        var estimatedTime = Math.round((gcode.length * 0.1) / 60);
                        alert('G-code g√©n√©r√© avec succ√®s!\n\n' +
                              'Fichier: ' + a.download + '\n\n' +
                              'üéØ Configuration Simplifi√©e:\n' +
                              '‚Ä¢ Pr√©cision: ' + LASER_CONFIG.precision + ' √©chantillons/mm (r√©solution d\'√©chantillonnage)\n' +
                              '‚Ä¢ Vitesse: ' + LASER_CONFIG.speed + ' mm/min (gravure)\n' +
                              '‚Ä¢ Puissance: ' + Math.round((LASER_CONFIG.power/255)*100) + '% (' + LASER_CONFIG.power + '/255 PWM)\n' +
                              '‚Ä¢ Mode qualit√©: ' + LASER_CONFIG.qualityMode + '\n' +
                              '‚Ä¢ D√©lais stabilisation: ' + LASER_CONFIG.powerStabilizationDelay + 'ms\n\n' +
                              '‚úÖ Taille physique constante: La pr√©cision affecte uniquement la r√©solution\n' +
                              '‚úÖ Balayage bidirectionnel: Zigzag sans retours X=0\n\n' +
                              '‚ö° Commandes machine:\n' +
                              '‚Ä¢ Laser ON: M106 Sxxx (ventilateur PWM)\n' +
                              '‚Ä¢ Laser OFF: M107\n' +
                              '‚Ä¢ Lignes G-code: ~' + gcode.length + '\n' +
                              '‚Ä¢ Temps estim√©: ~' + estimatedTime + ' minutes');
                    }, 500);
                }, 100);
            });
        }, 100);
    }, 100);
}

/**
 * Load machine profile configuration
 */
function loadMachineProfile(profileName) {
    if (LASER_CONFIG.machineProfiles[profileName]) {
        var profile = LASER_CONFIG.machineProfiles[profileName];
        
        // Update LASER_CONFIG with profile values
        LASER_CONFIG.maxPower = profile.maxPower;
        LASER_CONFIG.minPower = profile.minPower;
        LASER_CONFIG.feedRate = profile.feedRate;
        LASER_CONFIG.travelRate = profile.travelRate;
        LASER_CONFIG.laserOn = profile.laserOn;
        LASER_CONFIG.laserOff = profile.laserOff;
        LASER_CONFIG.powerCurve = profile.powerCurve;
        LASER_CONFIG.currentMachineProfile = profileName;
        
        // Update UI elements if they exist
        updateUIFromConfig();
        
        console.log('Machine profile loaded:', profile.name);
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'Profil machine charg√©: ' + profile.name;
            statusElement.style.color = '#28a745';
        }
        
        return true;
    }
    return false;
}

/**
 * Save current configuration as machine profile
 */
function saveMachineProfile(profileName, name) {
    LASER_CONFIG.machineProfiles[profileName] = {
        name: name,
        maxPower: LASER_CONFIG.maxPower,
        minPower: LASER_CONFIG.minPower,
        feedRate: LASER_CONFIG.feedRate,
        travelRate: LASER_CONFIG.travelRate,
        laserOn: LASER_CONFIG.laserOn,
        laserOff: LASER_CONFIG.laserOff,
        powerCurve: LASER_CONFIG.powerCurve
    };
    
    // Save to localStorage
    try {
        localStorage.setItem('laserMachineProfiles', JSON.stringify(LASER_CONFIG.machineProfiles));
        console.log('Machine profile saved:', name);
        return true;
    } catch (e) {
        console.error('Failed to save machine profile:', e);
        return false;
    }
}

/**
 * Load machine profiles from localStorage
 */
function loadMachineProfiles() {
    try {
        var saved = localStorage.getItem('laserMachineProfiles');
        if (saved) {
            var profiles = JSON.parse(saved);
            // Merge with default profiles
            LASER_CONFIG.machineProfiles = Object.assign(LASER_CONFIG.machineProfiles, profiles);
            console.log('Machine profiles loaded from storage');
        }
    } catch (e) {
        console.error('Failed to load machine profiles:', e);
    }
}

/**
 * Apply speed profile
 */
function applySpeedProfile(profileName) {
    if (LASER_CONFIG.speedProfiles[profileName]) {
        var profile = LASER_CONFIG.speedProfiles[profileName];
        LASER_CONFIG.feedRate = profile.feedRate;
        LASER_CONFIG.travelRate = profile.travelRate;
        LASER_CONFIG.currentSpeedProfile = profileName;
        
        updateUIFromConfig();
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'Profil vitesse appliqu√©: ' + profileName;
            statusElement.style.color = '#28a745';
        }
        
        console.log('Speed profile applied:', profileName, profile);
    }
}

/**
 * Apply resolution profile
 */
function applyResolutionProfile(profileName) {
    if (LASER_CONFIG.resolutionPresets[profileName]) {
        var preset = LASER_CONFIG.resolutionPresets[profileName];
        LASER_CONFIG.resolution = preset.resolution;
        LASER_CONFIG.currentResolutionProfile = profileName;
        
        updateUIFromConfig();
        
        var statusElement = document.getElementById('laserStatus');
        if (statusElement) {
            statusElement.textContent = 'R√©solution appliqu√©e: ' + preset.description;
            statusElement.style.color = '#28a745';
        }
        
        console.log('Resolution profile applied:', profileName, preset);
    }
}

/**
 * Update UI elements from current configuration
 */
function updateUIFromConfig() {
    // Update basic laser settings
    var maxPowerInput = document.getElementById('maxPower');
    var minPowerInput = document.getElementById('minPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var resolutionInput = document.getElementById('resolution');
    var powerCurveSelect = document.getElementById('powerCurve');
    
    if (maxPowerInput) maxPowerInput.value = LASER_CONFIG.maxPower;
    if (minPowerInput) minPowerInput.value = LASER_CONFIG.minPower;
    if (feedRateInput) feedRateInput.value = LASER_CONFIG.feedRate;
    if (travelRateInput) travelRateInput.value = LASER_CONFIG.travelRate;
    if (resolutionInput) resolutionInput.value = LASER_CONFIG.resolution;
    if (powerCurveSelect) powerCurveSelect.value = LASER_CONFIG.powerCurve;
    
    // Update profile selectors
    var speedProfileSelect = document.getElementById('speedProfile');
    var resolutionProfileSelect = document.getElementById('resolutionProfile');
    var machineProfileSelect = document.getElementById('machineProfile');
    
    if (speedProfileSelect) speedProfileSelect.value = LASER_CONFIG.currentSpeedProfile;
    if (resolutionProfileSelect) resolutionProfileSelect.value = LASER_CONFIG.currentResolutionProfile;
    if (machineProfileSelect) machineProfileSelect.value = LASER_CONFIG.currentMachineProfile;
    
    // Update advanced settings
    var adaptivePowerCheckbox = document.getElementById('adaptivePower');
    var optimizeTravelCheckbox = document.getElementById('optimizeTravel');
    var bidirectionalScanCheckbox = document.getElementById('bidirectionalScan');
    
    if (adaptivePowerCheckbox) adaptivePowerCheckbox.checked = LASER_CONFIG.adaptivePower;
    if (optimizeTravelCheckbox) optimizeTravelCheckbox.checked = LASER_CONFIG.optimizeTravel;
    if (bidirectionalScanCheckbox) bidirectionalScanCheckbox.checked = LASER_CONFIG.bidirectionalScan;
}

/**
 * Enhanced laser configuration update function
 */
function updateLaserConfig() {
    // Basic settings
    var maxPowerInput = document.getElementById('maxPower');
    var minPowerInput = document.getElementById('minPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var resolutionInput = document.getElementById('resolution');
    var powerCurveSelect = document.getElementById('powerCurve');
    var statusElement = document.getElementById('laserStatus');
    
    // Update configuration
    if (maxPowerInput) LASER_CONFIG.maxPower = parseInt(maxPowerInput.value) || 255;
    if (minPowerInput) LASER_CONFIG.minPower = parseInt(minPowerInput.value) || 5;
    if (feedRateInput) LASER_CONFIG.feedRate = parseInt(feedRateInput.value) || 1000;
    if (travelRateInput) LASER_CONFIG.travelRate = parseInt(travelRateInput.value) || 3000;
    if (resolutionInput) LASER_CONFIG.resolution = parseInt(resolutionInput.value) || 10;
    if (powerCurveSelect) LASER_CONFIG.powerCurve = powerCurveSelect.value || 'linear';
    
    // Advanced settings
    var adaptivePowerCheckbox = document.getElementById('adaptivePower');
    var optimizeTravelCheckbox = document.getElementById('optimizeTravel');
    var bidirectionalScanCheckbox = document.getElementById('bidirectionalScan');
    var lightThresholdInput = document.getElementById('lightBurnThreshold');
    var deepThresholdInput = document.getElementById('burnDeepThreshold');
    
    if (adaptivePowerCheckbox) LASER_CONFIG.adaptivePower = adaptivePowerCheckbox.checked;
    if (optimizeTravelCheckbox) LASER_CONFIG.optimizeTravel = optimizeTravelCheckbox.checked;
    if (bidirectionalScanCheckbox) LASER_CONFIG.bidirectionalScan = bidirectionalScanCheckbox.checked;
    if (lightThresholdInput) LASER_CONFIG.lightBurnThreshold = parseInt(lightThresholdInput.value) || 50;
    if (deepThresholdInput) LASER_CONFIG.burnDeepThreshold = parseInt(deepThresholdInput.value) || 200;
    
    // Save configuration to localStorage
    try {
        localStorage.setItem('laserConfig', JSON.stringify(LASER_CONFIG));
    } catch (e) {
        console.error('Failed to save laser configuration:', e);
    }
    
    if (statusElement) {
        statusElement.textContent = `Configuration mise √† jour: ${LASER_CONFIG.maxPower}/${LASER_CONFIG.minPower} PWM, ${LASER_CONFIG.feedRate}/${LASER_CONFIG.travelRate} mm/min, ${LASER_CONFIG.resolution} px/mm`;
        statusElement.style.color = '#28a745';
        
        // Reset color after 3 seconds
        setTimeout(function() {
            if (statusElement) {
                statusElement.style.color = '#666';
            }
        }, 3000);
    }
    
    console.log('Enhanced laser config updated:', LASER_CONFIG);
}

/**
 * Initialize laser configuration system
 */
function initializeLaserConfig() {
    // Load saved configuration
    try {
        var saved = localStorage.getItem('laserConfig');
        if (saved) {
            var savedConfig = JSON.parse(saved);
            // Merge with default configuration, preserving structure
            Object.assign(LASER_CONFIG, savedConfig);
            console.log('Laser configuration loaded from storage');
        }
    } catch (e) {
        console.error('Failed to load laser configuration:', e);
    }
    
    // Load machine profiles
    loadMachineProfiles();
    
    // Update UI to reflect current configuration
    updateUIFromConfig();
    
    console.log('Laser configuration system initialized');
}

// Initialize on page load
if (typeof window !== 'undefined') {
    window.addEventListener('load', function() {
        setTimeout(initializeLaserConfig, 100); // Small delay to ensure DOM is ready
    });
}

/**
 * Debug function to save canvas as image (DISABLED - G-code only mode)
 */
function debugSaveCanvasImage(canvas, filename) {
    // Image export completely disabled - G-code only mode
    console.log('Debug image export disabled (G-code only mode):', filename);
    // No image generation or download - function serves as stub only
}

/**
 * Find the bounding box of content in image data
 * @param {Uint8ClampedArray} data - Image data
 * @param {number} width - Image width
 * @param {number} height - Image height
 * @param {number} threshold - Threshold for detecting content (0-255)
 * @returns {Object|null} Bounding box {x, y, width, height} or null if no content
 */
function findImageBoundsWithThreshold(data, width, height, threshold) {
    var minX = width, minY = height, maxX = 0, maxY = 0;
    var hasContent = false;
    
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pixelIndex = (y * width + x) * 4;
            var r = data[pixelIndex];
            var g = data[pixelIndex + 1];
            var b = data[pixelIndex + 2];
            var alpha = data[pixelIndex + 3];
            
            // Convert to grayscale
            var grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            
            // Check if pixel is not white/transparent (content)
            if (alpha > 0 && grayscale < threshold) {
                hasContent = true;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
    }
    
    if (!hasContent) {
        return null;
    }
    
    return {
        x: minX,
        y: minY,
        width: maxX - minX + 1,
        height: maxY - minY + 1
    };
}

/**
 * Crop image data to specified bounds
 * @param {Uint8ClampedArray} data - Original image data
 * @param {number} width - Original image width
 * @param {number} height - Original image height
 * @param {Object} bounds - Crop bounds {x, y, width, height}
 * @returns {Uint8ClampedArray} Cropped image data
 */
function cropImageData(data, width, height, bounds) {
    var croppedData = new Uint8ClampedArray(bounds.width * bounds.height * 4);
    
    for (var y = 0; y < bounds.height; y++) {
        for (var x = 0; x < bounds.width; x++) {
            var srcX = bounds.x + x;
            var srcY = bounds.y + y;
            
            // Ensure we don't go out of bounds
            if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
                var srcIndex = (srcY * width + srcX) * 4;
                var destIndex = (y * bounds.width + x) * 4;
                
                croppedData[destIndex] = data[srcIndex];         // R
                croppedData[destIndex + 1] = data[srcIndex + 1]; // G
                croppedData[destIndex + 2] = data[srcIndex + 2]; // B
                croppedData[destIndex + 3] = data[srcIndex + 3]; // A
            }
        }
    }
    
    return croppedData;
}

/**
 * Apply quality preset
 * @param {string} presetName - Name of the quality preset
 */
function applyQualityPreset(presetName) {
    if (LASER_CONFIG.qualityPresets[presetName]) {
        var preset = LASER_CONFIG.qualityPresets[presetName];
        
        LASER_CONFIG.precision = preset.precision;
        LASER_CONFIG.speed = preset.speed;
        LASER_CONFIG.powerStabilizationDelay = preset.powerStabilizationDelay;
        LASER_CONFIG.minMovementDelay = preset.minMovementDelay;
        LASER_CONFIG.qualityMode = presetName;
        
        // Auto-calculate travel rate
        LASER_CONFIG.travelRate = Math.min(LASER_CONFIG.speed * 3, 5000);
        
        updateSimplifiedUI();
        
        console.log('Quality preset applied:', presetName, preset);
        
        // Show status message
        showTemporaryMessage('Preset "' + preset.description + '" appliqu√©');
    }
}

/**
 * Update simplified UI elements
 */
function updateSimplifiedUI() {
    // Update main controls
    var precisionInput = document.getElementById('simplePrecision');
    var speedInput = document.getElementById('simpleSpeed');
    var powerInput = document.getElementById('simplePower');
    var qualitySelect = document.getElementById('qualityPreset');
    
    if (precisionInput) precisionInput.value = LASER_CONFIG.precision;
    if (speedInput) speedInput.value = LASER_CONFIG.speed;
    if (powerInput) powerInput.value = LASER_CONFIG.power;
    if (qualitySelect) qualitySelect.value = LASER_CONFIG.qualityMode;
    
    // Update display values
    var precisionDisplay = document.getElementById('precisionDisplay');
    var speedDisplay = document.getElementById('speedDisplay');
    var powerDisplay = document.getElementById('powerDisplay');
    
    if (precisionDisplay) {
        precisionDisplay.textContent = LASER_CONFIG.precision + ' px/mm (' + (1/LASER_CONFIG.precision).toFixed(2) + 'mm)';
    }
    if (speedDisplay) {
        speedDisplay.textContent = LASER_CONFIG.speed + ' mm/min';
    }
    if (powerDisplay) {
        powerDisplay.textContent = Math.round((LASER_CONFIG.power/255)*100) + '% (' + LASER_CONFIG.power + '/255)';
    }
}

/**
 * Update single parameter and recalculate dependent values
 */
function updateSimplifiedConfig() {
    var precisionInput = document.getElementById('simplePrecision');
    var speedInput = document.getElementById('simpleSpeed');
    var powerInput = document.getElementById('simplePower');
    
    if (precisionInput) LASER_CONFIG.precision = parseInt(precisionInput.value) || 10;
    if (speedInput) LASER_CONFIG.speed = parseInt(speedInput.value) || 1000;
    if (powerInput) LASER_CONFIG.power = parseInt(powerInput.value) || 128;
    
    // Auto-calculate travel rate
    LASER_CONFIG.travelRate = Math.min(LASER_CONFIG.speed * 3, 5000);
    
    // Update quality mode to custom if manually changed
    LASER_CONFIG.qualityMode = 'custom';
    
    updateSimplifiedUI();
    
    // Save to localStorage
    try {
        localStorage.setItem('simpleLaserConfig', JSON.stringify({
            precision: LASER_CONFIG.precision,
            speed: LASER_CONFIG.speed,
            power: LASER_CONFIG.power,
            qualityMode: LASER_CONFIG.qualityMode
        }));
    } catch (e) {
        console.error('Failed to save simplified config:', e);
    }
    
    console.log('Simplified config updated:', {
        precision: LASER_CONFIG.precision,
        speed: LASER_CONFIG.speed,
        power: LASER_CONFIG.power,
        travelRate: LASER_CONFIG.travelRate
    });
}

/**
 * Show temporary status message
 */
function showTemporaryMessage(message) {
    var messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(76, 175, 80, 0.95);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: messageSlide 2s ease-in-out;
    `;
    messageDiv.textContent = message;
    
    document.body.appendChild(messageDiv);
    
    setTimeout(function() {
        if (messageDiv.parentNode) {
            messageDiv.parentNode.removeChild(messageDiv);
        }
    }, 2000);
}

/**
 * Initialize simplified laser configuration
 */
function initializeSimplifiedConfig() {
    // Load saved simplified configuration
    try {
        var saved = localStorage.getItem('simpleLaserConfig');
        if (saved) {
            var savedConfig = JSON.parse(saved);
            LASER_CONFIG.precision = savedConfig.precision || 10;
            LASER_CONFIG.speed = savedConfig.speed || 1000;
            LASER_CONFIG.power = savedConfig.power || 128;
            LASER_CONFIG.qualityMode = savedConfig.qualityMode || 'balanced';
            console.log('Simplified laser configuration loaded from storage');
        }
    } catch (e) {
        console.error('Failed to load simplified configuration:', e);
    }
    
    // Set default quality preset if not custom
    if (LASER_CONFIG.qualityMode !== 'custom' && LASER_CONFIG.qualityPresets[LASER_CONFIG.qualityMode]) {
        var preset = LASER_CONFIG.qualityPresets[LASER_CONFIG.qualityMode];
        LASER_CONFIG.powerStabilizationDelay = preset.powerStabilizationDelay;
        LASER_CONFIG.minMovementDelay = preset.minMovementDelay;
    }
    
    // Auto-calculate travel rate
    LASER_CONFIG.travelRate = Math.min(LASER_CONFIG.speed * 3, 5000);
    
    // Update UI to reflect current configuration
    updateSimplifiedUI();
    
    console.log('Simplified laser configuration system initialized:', {
        precision: LASER_CONFIG.precision,
        speed: LASER_CONFIG.speed,
        power: LASER_CONFIG.power,
        qualityMode: LASER_CONFIG.qualityMode
    });
}

/**
 * Toggle advanced laser options visibility
 */
function toggleAdvancedOptions() {
    var advancedGroup = document.querySelector('.advanced-group');
    var showAdvancedBtn = document.getElementById('showAdvancedBtn');
    
    if (advancedGroup && showAdvancedBtn) {
        if (advancedGroup.style.display === 'none') {
            advancedGroup.style.display = 'block';
            showAdvancedBtn.style.display = 'none';
        } else {
            advancedGroup.style.display = 'none';
            showAdvancedBtn.style.display = 'block';
        }
    }
}
