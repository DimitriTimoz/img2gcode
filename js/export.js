/**
 * Export Functionality Module
 * Handles G-code export for laser engraving on Ender 3
 */

// Laser engraving settings for Ender 3
var LASER_CONFIG = {
    maxPower: 255,        // Maximum fan PWM value (0-255)
    minPower: 5,          // Minimum power for light engraving (avoid very light burns)
    feedRate: 1000,       // Feed rate in mm/min for engraving
    travelRate: 3000,     // Travel rate for non-cutting moves
    rapidRate: 5000,      // Rapid movement rate for long distances
    laserOn: 'M106',      // Fan on command (controls laser)
    laserOff: 'M107',     // Fan off command
    units: 'G21',         // Millimeters
    positioning: 'G90',   // Absolute positioning
    homeX: 0,             // Home X position
    homeY: 0,             // Home Y position
    resolution: 10,       // Default resolution in pixels per mm (0.1mm precision)
    burnDelay: 0,         // Delay in ms between power changes (for laser stabilization)
    safetyHeight: 0,      // Z height for safety (if applicable)
    powerCurve: 'linear'  // Power curve: 'linear', 'exponential', 'custom'
};

/**
 * Generate G-code header
 */
function generateGcodeHeader() {
    var header = [
        '; Generated by Image to G-Code Converter',
        '; For Ender 3 with laser engraving (fan-controlled)',
        '; Date: ' + new Date().toLocaleString(),
        '',
        '; Initialize - No homing required',
        '; Current position will be used as origin (0,0)',
        LASER_CONFIG.units + ' ; Set units to millimeters',
        LASER_CONFIG.positioning + ' ; Absolute positioning',
        'G92 X0 Y0 Z0 ; Set current position as origin (0,0,0)',
        'F' + LASER_CONFIG.travelRate + ' ; Set travel feed rate',
        LASER_CONFIG.laserOff + ' ; Ensure laser is off',
        '',
        '; Begin engraving',
        ''
    ];
    return header.join('\n');
}

/**
 * Generate G-code footer
 */
function generateGcodeFooter() {
    var footer = [
        '',
        '; End engraving',
        LASER_CONFIG.laserOff + ' ; Turn off laser',
        'G0 X0 Y0 ; Return to origin',
        'M84 ; Disable steppers',
        '; End of G-code'
    ];
    return footer.join('\n');
}

/**
 * Convert grayscale value to laser power (0-255)
 */
function grayscaleToLaserPower(grayscale) {
    // Invert grayscale: darker = more power
    var inverted = 255 - grayscale;
    
    // Map to laser power range (skip very light areas)
    var threshold = 10; // Don't engrave very light areas
    if (inverted < threshold) return 0;
    
    // Apply power curve
    var normalizedPower;
    if (LASER_CONFIG.powerCurve === 'exponential') {
        // Exponential curve for more aggressive contrast
        normalizedPower = Math.pow(inverted / 255, 0.7);
    } else {
        // Linear curve (default)
        normalizedPower = inverted / 255;
    }
    
    // Map to power range between minPower and maxPower
    var powerRange = LASER_CONFIG.maxPower - LASER_CONFIG.minPower;
    var laserPower = Math.round(LASER_CONFIG.minPower + (normalizedPower * powerRange));
    
    // Ensure we don't go below minimum power for actual burning
    return Math.max(LASER_CONFIG.minPower, Math.min(LASER_CONFIG.maxPower, laserPower));
}

/**
 * Convert canvas to image data (without grid) and generate G-code
 */
function processCanvasToGcode() {
    console.log('Converting canvas to image for laser engraving...');
    
    // Temporarily hide grid elements completely (remove from canvas)
    var gridElements = canvas.getObjects().filter(function(obj) {
        return obj.excludeFromExport;
    });
    
    console.log('Removing', gridElements.length, 'grid elements temporarily');
    gridElements.forEach(function(obj) {
        canvas.remove(obj);
    });
    
    canvas.renderAll();
    
    // For debugging, let's try extracting the entire canvas first (without grid)
    var fabricCanvasElement = canvas.getElement();
    console.log('Fabric canvas element size:', fabricCanvasElement.width, 'x', fabricCanvasElement.height);
    
    // Try full canvas extraction for debugging (clean canvas without grid)
    var debugFullCanvas = document.createElement('canvas');
    var debugFullCtx = debugFullCanvas.getContext('2d');
    debugFullCanvas.width = fabricCanvasElement.width;
    debugFullCanvas.height = fabricCanvasElement.height;
    debugFullCtx.fillStyle = 'white';
    debugFullCtx.fillRect(0, 0, debugFullCanvas.width, debugFullCanvas.height);
    debugFullCtx.drawImage(fabricCanvasElement, 0, 0);
    debugSaveCanvasImage(debugFullCanvas, 'debug_full_canvas_clean.png');
    
    // Check if there are any content objects and their positions
    var objects = canvas.getObjects(); // All remaining objects (no grid)
    console.log('Content objects on canvas:', objects.length);
    objects.forEach(function(obj, index) {
        var bounds = obj.getBoundingRect();
        console.log(`Object ${index}:`, obj.type, 'text:', obj.text || 'N/A', 'at', bounds);
    });
    
    if (objects.length === 0) {
        console.log('No content objects found after grid removal');
        // Restore grid elements
        gridElements.forEach(function(obj) {
            canvas.add(obj);
        });
        canvas.renderAll();
        return '';
    }
    
    // Use the full canvas approach since it's simpler and more reliable
    var fullCanvas = document.createElement('canvas');
    var fullCtx = fullCanvas.getContext('2d');
    fullCanvas.width = fabricCanvasElement.width;
    fullCanvas.height = fabricCanvasElement.height;
    
    // Fill with white background
    fullCtx.fillStyle = 'white';
    fullCtx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
    
    // Draw the clean canvas content
    fullCtx.drawImage(fabricCanvasElement, 0, 0);
    
    // Get image data from full canvas
    var fullImageData = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);
    var data = fullImageData.data;
    
    // Find bounding box of content
    var bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 200);
    
    if (!bounds) {
        console.log('Trying even more lenient threshold...');
        bounds = findImageBoundsWithThreshold(data, fullCanvas.width, fullCanvas.height, 100);
    }
    
    if (!bounds) {
        console.log('Still no content found, using full canvas');
        bounds = { x: 0, y: 0, width: fullCanvas.width, height: fullCanvas.height };
    }
    
    console.log('Content bounds found:', bounds);
    
    // Crop the content
    var croppedData = cropImageData(data, fullCanvas.width, fullCanvas.height, bounds);
    var croppedWidth = bounds.width;
    var croppedHeight = bounds.height;
    
    // Calculate real-world dimensions - use the workspace config for conversion
    var pixelToMmRatio = WORKSPACE_CONFIG.width / WORKSPACE_CONFIG.canvasWidth;
    var croppedWidthMm = croppedWidth * pixelToMmRatio;
    var croppedHeightMm = croppedHeight * pixelToMmRatio;
    var resolution = 1 / pixelToMmRatio; // pixels per mm
    
    console.log(`Final dimensions: ${croppedWidthMm.toFixed(2)}x${croppedHeightMm.toFixed(2)}mm`);
    console.log(`Resolution: ${resolution.toFixed(2)} pixels/mm`);
    
    // Save debug image of cropped content
    var croppedCanvas = document.createElement('canvas');
    var croppedCtx = croppedCanvas.getContext('2d');
    croppedCanvas.width = croppedWidth;
    croppedCanvas.height = croppedHeight;
    var croppedImageData = new ImageData(croppedData, croppedWidth, croppedHeight);
    croppedCtx.putImageData(croppedImageData, 0, 0);
    debugSaveCanvasImage(croppedCanvas, 'debug_cropped_content.png');
    
    // Generate G-code header
    var gcode = [];
    gcode.push('; Canvas raster engraving (cropped): ' + croppedWidthMm.toFixed(2) + 'x' + croppedHeightMm.toFixed(2) + 'mm');
    gcode.push('; Original canvas: ' + WORKSPACE_CONFIG.width + 'x' + WORKSPACE_CONFIG.height + 'mm');
    gcode.push('; Resolution: ' + resolution.toFixed(2) + ' pixels/mm (' + (1/resolution).toFixed(3) + 'mm per pixel)');
    gcode.push('; Cropped pixels: ' + croppedWidth + 'x' + croppedHeight);
    gcode.push('; Origin: Current printer position (bottom-left of workspace)');
    gcode.push('');
    
    var pixelSize = 1 / resolution; // Size of each pixel in mm
    var currentLaserPower = 0;
    var lastX = 0;
    
    // Process line by line (raster scan) - start from bottom (Y=0) and work up
    // Canvas coordinates are top-down, but we want bottom-left origin for G-code
    for (var canvasY = croppedHeight - 1; canvasY >= 0; canvasY--) {
        var yPos = (croppedHeight - 1 - canvasY) * pixelSize; // Convert to bottom-left coordinate system
        var rowHasContent = false;
        var rowData = [];
        
        // Pre-scan the row to see if it has any content
        for (var x = 0; x < croppedWidth; x++) {
            var pixelIndex = (canvasY * croppedWidth + x) * 4;
            var r = croppedData[pixelIndex];
            var g = croppedData[pixelIndex + 1];
            var b = croppedData[pixelIndex + 2];
            var alpha = croppedData[pixelIndex + 3];
            
            // Convert to grayscale
            var grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            var laserPower = grayscaleToLaserPower(grayscale);
            
            rowData.push({
                x: x,
                power: laserPower,
                grayscale: grayscale
            });
            
            if (laserPower > 0) {
                rowHasContent = true;
            }
        }
        
        if (!rowHasContent) {
            continue; // Skip empty rows
        }
        
        // Optimize row direction (bidirectional scanning)
        var rowIndex = croppedHeight - 1 - canvasY;
        var isEvenRow = (rowIndex % 2) === 0;
        if (!isEvenRow) {
            rowData.reverse(); // Reverse odd rows for zigzag pattern
        }
        
        // Move to start of row
        var startX = isEvenRow ? 0 : (croppedWidth - 1) * pixelSize;
        if (Math.abs(startX - lastX) > 0.1) { // Only move if significant distance
            gcode.push('G0 X' + startX.toFixed(2) + ' Y' + yPos.toFixed(2) + ' F' + LASER_CONFIG.travelRate + ' ; Move to row ' + rowIndex);
            lastX = startX;
        } else {
            gcode.push('G0 Y' + yPos.toFixed(2) + ' ; Next row ' + rowIndex);
        }
        
        // Process pixels in this row
        var segmentStart = null;
        var segmentPower = 0;
        
        for (var i = 0; i < rowData.length; i++) {
            var pixel = rowData[i];
            var xPos = pixel.x * pixelSize;
            
            if (pixel.power > 0) {
                if (segmentStart === null) {
                    // Start new laser segment
                    segmentStart = xPos;
                    segmentPower = pixel.power;
                    
                    if (currentLaserPower !== pixel.power) {
                        gcode.push('M106 S' + pixel.power + ' ; Laser power ' + Math.round((pixel.power/255)*100) + '%');
                        currentLaserPower = pixel.power;
                    }
                    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Engraving speed');
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Start burn');
                } else if (Math.abs(pixel.power - segmentPower) > 5) {
                    // Power change - end current segment and start new one
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Continue burn');
                    gcode.push('M106 S' + pixel.power + ' ; Power change to ' + Math.round((pixel.power/255)*100) + '%');
                    segmentPower = pixel.power;
                    currentLaserPower = pixel.power;
                } else {
                    // Continue current segment
                    if (i === rowData.length - 1 || i % 5 === 0) { // Output position every 5 pixels or at end
                        gcode.push('G1 X' + xPos.toFixed(2) + ' ; Burn');
                    }
                }
            } else {
                if (segmentStart !== null) {
                    // End laser segment
                    gcode.push(LASER_CONFIG.laserOff + ' ; End burn segment');
                    currentLaserPower = 0;
                    segmentStart = null;
                }
                
                // Skip to next burning pixel if there are any
                var nextBurnIndex = -1;
                for (var j = i + 1; j < rowData.length; j++) {
                    if (rowData[j].power > 0) {
                        nextBurnIndex = j;
                        break;
                    }
                }
                
                if (nextBurnIndex > -1 && nextBurnIndex - i > 3) {
                    // Jump to next burn area if it's far enough
                    var nextXPos = rowData[nextBurnIndex].x * pixelSize;
                    gcode.push('G0 X' + nextXPos.toFixed(2) + ' F' + LASER_CONFIG.travelRate + ' ; Skip to next burn area');
                    i = nextBurnIndex - 1; // -1 because loop will increment
                    lastX = nextXPos;
                }
            }
            
            lastX = xPos;
        }
        
        // Ensure laser is off at end of row
        if (currentLaserPower > 0) {
            gcode.push(LASER_CONFIG.laserOff + ' ; End of row');
            currentLaserPower = 0;
        }
        
        // Progress indicator
        if (rowIndex % 10 === 0) {
            var progress = Math.round((rowIndex / croppedHeight) * 100);
            gcode.push('; Progress: ' + progress + '% (row ' + rowIndex + '/' + croppedHeight + ')');
        }
    }
    
    // Restore grid elements
    console.log('Restoring', gridElements.length, 'grid elements');
    gridElements.forEach(function(obj) {
        canvas.add(obj);
    });
    canvas.renderAll();
    
    return gcode.join('\n');
}

/**
 * Process text object and generate G-code for vector engraving
 */
function processTextToGcode(textObj) {
    console.log('Processing text for laser engraving...');
    
    var bounds = textObj.getBoundingRect();
    var xOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.left - WORKSPACE_CONFIG.usableArea.offsetX);
    var yOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.top - WORKSPACE_CONFIG.usableArea.offsetY);
    var widthMm = WORKSPACE_CONFIG.pixelsToMm(bounds.width);
    var heightMm = WORKSPACE_CONFIG.pixelsToMm(bounds.height);
    
    var gcode = [];
    gcode.push('; Vector text engraving: "' + textObj.text + '"');
    gcode.push('; Font: ' + textObj.fontFamily + ', Size: ' + WORKSPACE_CONFIG.pixelsToMm(textObj.fontSize).toFixed(1) + 'mm');
    gcode.push('; Position: X' + xOffsetMm.toFixed(1) + ' Y' + yOffsetMm.toFixed(1));
    gcode.push('; Dimensions: ' + widthMm.toFixed(1) + 'x' + heightMm.toFixed(1) + 'mm');
    gcode.push('');
    
    // For text, we'll create a simple outline engraving
    var laserPower = Math.round(LASER_CONFIG.maxPower * 0.7); // 70% power for text
    
    gcode.push('; Text outline engraving');
    gcode.push('G0 X' + xOffsetMm.toFixed(2) + ' Y' + yOffsetMm.toFixed(2) + ' ; Move to text start');
    gcode.push('M106 S' + laserPower + ' ; Set laser power to ' + Math.round((laserPower/255)*100) + '%');
    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Set engraving speed');
    
    // Create a simple rectangular outline for text (in a real implementation, you'd trace the actual font paths)
    gcode.push('G1 X' + (xOffsetMm + widthMm).toFixed(2) + ' ; Right edge');
    gcode.push('G1 Y' + (yOffsetMm + heightMm).toFixed(2) + ' ; Top edge');  
    gcode.push('G1 X' + xOffsetMm.toFixed(2) + ' ; Left edge');
    gcode.push('G1 Y' + yOffsetMm.toFixed(2) + ' ; Bottom edge');
    
    gcode.push(LASER_CONFIG.laserOff + ' ; Turn off laser');
    
    return gcode.join('\n');
}

/**
 * Export canvas content as G-code for laser engraving
 */
function downloadGcode() {
    // Check if there's anything on the canvas to export (excluding grid)
    var exportableObjects = canvas.getObjects().filter(function(obj) {
        return !obj.excludeFromExport;
    });

    if (exportableObjects.length === 0) {
        alert('Le canevas est vide. Ajoutez des objets avant d\'exporter.');
        return;
    }

    console.log('Generating G-code for the entire canvas as a single image...');

    var gcode = [];

    // Add header
    gcode.push(generateGcodeHeader());

    // Process the entire canvas as one image
    gcode.push('; Processing entire canvas as a single image');
    var canvasGcode = processCanvasToGcode(); // This function handles the whole canvas
    if (canvasGcode && canvasGcode.trim() !== '') {
        gcode.push(canvasGcode);
    } else {
        console.log('processCanvasToGcode returned empty or whitespace only G-code. This might happen if the canvas is effectively blank.');
        // Optionally, you could alert the user here or add a comment to the G-code file.
        gcode.push('; Warning: Canvas content resulted in empty G-code.');
    }
    gcode.push(''); // Add a blank line for separation

    // Add footer
    gcode.push(generateGcodeFooter());

    var finalGcode = gcode.join('\n');

    // Show preview of G-code
    console.log('Generated G-code:');
    console.log(finalGcode);

    // Create file and download
    var blob = new Blob([finalGcode], { type: 'text/plain' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    // Changed filename to reflect it's a full canvas export
    a.download = currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '_canvas.gcode';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Show success message
    alert('G-code généré avec succès pour l\'ensemble du canevas!\n\n' +
          'Fichier: ' + a.download + '\n\n' +
          'Configuration laser:\n' +
          '- Commande ON: M106 (contrôle du ventilateur)\n' +
          '- Commande OFF: M107\n' +
          '- Puissance max: ' + LASER_CONFIG.maxPower + ' (PWM)\n' +
          '- Vitesse gravure: ' + LASER_CONFIG.feedRate + ' mm/min\n' +
          '- Vitesse déplacement: ' + LASER_CONFIG.travelRate + ' mm/min');
}

/**
 * Update laser configuration from UI
 */
function updateLaserConfig() {
    var maxPowerInput = document.getElementById('maxPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var statusElement = document.getElementById('laserStatus');
    
    if (maxPowerInput) LASER_CONFIG.maxPower = parseInt(maxPowerInput.value) || 255;
    if (feedRateInput) LASER_CONFIG.feedRate = parseInt(feedRateInput.value) || 1000;
    if (travelRateInput) LASER_CONFIG.travelRate = parseInt(travelRateInput.value) || 3000;
    
    if (statusElement) {
        statusElement.textContent = `Configuration mise à jour: ${LASER_CONFIG.maxPower} PWM, ${LASER_CONFIG.feedRate}/${LASER_CONFIG.travelRate} mm/min`;
        statusElement.style.color = '#28a745';
        
        // Reset color after 3 seconds
        setTimeout(function() {
            if (statusElement) {
                statusElement.style.color = '#666';
            }
        }, 3000);
    }
    
    console.log('Laser config updated:', LASER_CONFIG);
}

/**
 * Find the bounding box of non-white pixels in image data
 */
function findImageBounds(data, width, height) {
    var minX = width;
    var maxX = -1;
    var minY = height;
    var maxY = -1;
    
    var threshold = 240; // Consider pixels with RGB values below this as content (more lenient)
    var pixelsChecked = 0;
    var contentPixels = 0;
    
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pixelIndex = (y * width + x) * 4;
            var r = data[pixelIndex];
            var g = data[pixelIndex + 1];
            var b = data[pixelIndex + 2];
            var alpha = data[pixelIndex + 3];
            
            pixelsChecked++;
            
            // Check if pixel is not white/transparent
            if (alpha > 0 && (r < threshold || g < threshold || b < threshold)) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                contentPixels++;
                
                // Log first few content pixels for debugging
                if (contentPixels <= 5) {
                    console.log(`Content pixel ${contentPixels}: (${x},${y}) RGB(${r},${g},${b}) A=${alpha}`);
                }
            }
        }
    }
    
    console.log(`Bounds detection: checked ${pixelsChecked} pixels, found ${contentPixels} content pixels`);
    console.log(`Threshold: ${threshold}, bounds: minX=${minX}, maxX=${maxX}, minY=${minY}, maxY=${maxY}`);
    
    // If no content found
    if (maxX === -1) {
        return null;
    }
    
    // Add small padding (1 pixel on each side)
    minX = Math.max(0, minX - 1);
    minY = Math.max(0, minY - 1);
    maxX = Math.min(width - 1, maxX + 1);
    maxY = Math.min(height - 1, maxY + 1);
    
    var bounds = {
        x: minX,
        y: minY,
        width: maxX - minX + 1,
        height: maxY - minY + 1
    };
    
    console.log('Final bounds:', bounds);
    return bounds;
}

/**
 * Find the bounding box of non-white pixels with a specific threshold
 */
function findImageBoundsWithThreshold(data, width, height, threshold) {
    var minX = width;
    var maxX = -1;
    var minY = height;
    var maxY = -1;
    
    var contentPixels = 0;
    
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var pixelIndex = (y * width + x) * 4;
            var r = data[pixelIndex];
            var g = data[pixelIndex + 1];
            var b = data[pixelIndex + 2];
            var alpha = data[pixelIndex + 3];
            
            // Check if pixel is not white/transparent
            if (alpha > 0 && (r < threshold || g < threshold || b < threshold)) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                contentPixels++;
            }
        }
    }
    
    console.log(`Threshold ${threshold}: found ${contentPixels} content pixels`);
    
    // If no content found
    if (maxX === -1) {
        return null;
    }
    
    // Add small padding (1 pixel on each side)
    minX = Math.max(0, minX - 1);
    minY = Math.max(0, minY - 1);
    maxX = Math.min(width - 1, maxX + 1);
    maxY = Math.min(height - 1, maxY + 1);
    
    var bounds = {
        x: minX,
        y: minY,
        width: maxX - minX + 1,
        height: maxY - minY + 1
    };
    
    console.log(`Bounds with threshold ${threshold}:`, bounds);
    return bounds;
}

/**
 * Crop image data to specified bounds
 */
function cropImageData(data, width, height, bounds) {
    var croppedData = new Uint8ClampedArray(bounds.width * bounds.height * 4);
    
    for (var y = 0; y < bounds.height; y++) {
        for (var x = 0; x < bounds.width; x++) {
            var sourceX = bounds.x + x;
            var sourceY = bounds.y + y;
            var sourceIndex = (sourceY * width + sourceX) * 4;
            var targetIndex = (y * bounds.width + x) * 4;
            
            // Copy RGBA values
            croppedData[targetIndex] = data[sourceIndex];
            croppedData[targetIndex + 1] = data[sourceIndex + 1];
            croppedData[targetIndex + 2] = data[sourceIndex + 2];
            croppedData[targetIndex + 3] = data[sourceIndex + 3];
        }
    }
    
    return croppedData;
}

/**
 * Debug function to save the canvas image data for inspection
 */
function debugSaveCanvasImage(tempCanvas, filename) {
    try {
        var link = document.createElement('a');
        link.download = filename || 'debug_canvas.png';
        link.href = tempCanvas.toDataURL();
        link.click();
        console.log('Debug image saved:', link.download);
    } catch (e) {
        console.log('Could not save debug image:', e);
    }
}
