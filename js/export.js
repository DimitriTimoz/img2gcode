/**
 * Export Functionality Module
 * Handles G-code export for laser engraving on Ender 3
 */

// Laser engraving settings for Ender 3
var LASER_CONFIG = {
    maxPower: 255,        // Maximum fan PWM value (0-255)
    minPower: 0,          // Minimum power for moves
    feedRate: 1000,       // Feed rate in mm/min for engraving
    travelRate: 3000,     // Travel rate for non-cutting moves
    laserOn: 'M106',      // Fan on command (controls laser)
    laserOff: 'M107',     // Fan off command
    units: 'G21',         // Millimeters
    positioning: 'G90',   // Absolute positioning
    homeX: 0,             // Home X position
    homeY: 0              // Home Y position
};

/**
 * Generate G-code header
 */
function generateGcodeHeader() {
    var header = [
        '; Generated by Image to G-Code Converter',
        '; For Ender 3 with laser engraving (fan-controlled)',
        '; Date: ' + new Date().toLocaleString(),
        '',
        '; Initialize - No homing required',
        '; Current position will be used as origin (0,0)',
        LASER_CONFIG.units + ' ; Set units to millimeters',
        LASER_CONFIG.positioning + ' ; Absolute positioning',
        'G92 X0 Y0 Z0 ; Set current position as origin (0,0,0)',
        'F' + LASER_CONFIG.travelRate + ' ; Set travel feed rate',
        LASER_CONFIG.laserOff + ' ; Ensure laser is off',
        '',
        '; Begin engraving',
        ''
    ];
    return header.join('\n');
}

/**
 * Generate G-code footer
 */
function generateGcodeFooter() {
    var footer = [
        '',
        '; End engraving',
        LASER_CONFIG.laserOff + ' ; Turn off laser',
        'G0 X0 Y0 ; Return to origin',
        'M84 ; Disable steppers',
        '; End of G-code'
    ];
    return footer.join('\n');
}

/**
 * Convert grayscale value to laser power (0-255)
 */
function grayscaleToLaserPower(grayscale) {
    // Invert grayscale: darker = more power
    var inverted = 255 - grayscale;
    
    // Map to laser power range (skip very light areas)
    if (inverted < 10) return 0; // Don't engrave very light areas
    
    return Math.round((inverted / 255) * LASER_CONFIG.maxPower);
}

/**
 * Convert canvas to image data (without grid) and generate G-code
 */
function processCanvasToGcode() {
    console.log('Converting canvas to image for laser engraving...');
    
    // Temporarily hide grid elements
    var gridElements = canvas.getObjects().filter(function(obj) {
        return obj.excludeFromExport;
    });
    
    gridElements.forEach(function(obj) {
        obj.set('opacity', 0);
    });
    
    canvas.renderAll();
    
    // Get the usable area bounds
    var area = WORKSPACE_CONFIG.usableArea;
    
    // Create a temporary canvas for cropping to workspace area only
    var tempCanvas = document.createElement('canvas');
    var tempCtx = tempCanvas.getContext('2d');
    
    // Set high resolution for engraving (10 pixels per mm = 0.1mm resolution)
    var resolution = 10; // pixels per mm
    var widthMm = WORKSPACE_CONFIG.width;
    var heightMm = WORKSPACE_CONFIG.height;
    
    tempCanvas.width = Math.round(widthMm * resolution);
    tempCanvas.height = Math.round(heightMm * resolution);
    
    // Fill with white background (no engraving)
    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // Calculate scale factor to map canvas pixels to our target resolution
    var scaleX = tempCanvas.width / area.width;
    var scaleY = tempCanvas.height / area.height;
    
    // Draw the fabric canvas content (only the workspace area) onto temp canvas
    var fabricCanvasElement = canvas.getElement();
    tempCtx.drawImage(
        fabricCanvasElement,
        area.offsetX, area.offsetY, area.width, area.height, // Source area (workspace area only)
        0, 0, tempCanvas.width, tempCanvas.height // Destination (full temp canvas)
    );
    
    // Restore grid visibility
    gridElements.forEach(function(obj) {
        obj.set('opacity', 1);
    });
    canvas.renderAll();
    
    // Get image data
    var imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    var data = imageData.data;
    
    // Generate G-code header
    var gcode = [];
    gcode.push('; Canvas raster engraving: ' + widthMm + 'x' + heightMm + 'mm');
    gcode.push('; Resolution: ' + resolution + ' pixels/mm (' + (1/resolution).toFixed(1) + 'mm per pixel)');
    gcode.push('; Total pixels: ' + tempCanvas.width + 'x' + tempCanvas.height);
    gcode.push('; Origin: Current printer position (bottom-left of workspace)');
    gcode.push('');
    
    var pixelSize = 1 / resolution; // Size of each pixel in mm
    var currentLaserPower = 0;
    var lastX = 0;
    
    // Process line by line (raster scan) - start from bottom (Y=0) and work up
    // Canvas coordinates are top-down, but we want bottom-left origin for G-code
    for (var canvasY = tempCanvas.height - 1; canvasY >= 0; canvasY--) {
        var yPos = (tempCanvas.height - 1 - canvasY) * pixelSize; // Convert to bottom-left coordinate system
        var rowHasContent = false;
        var rowData = [];
        
        // Pre-scan the row to see if it has any content
        for (var x = 0; x < tempCanvas.width; x++) {
            var pixelIndex = (canvasY * tempCanvas.width + x) * 4;
            var r = data[pixelIndex];
            var g = data[pixelIndex + 1];
            var b = data[pixelIndex + 2];
            var alpha = data[pixelIndex + 3];
            
            // Convert to grayscale
            var grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            var laserPower = grayscaleToLaserPower(grayscale);
            
            rowData.push({
                x: x,
                power: laserPower,
                grayscale: grayscale
            });
            
            if (laserPower > 0) {
                rowHasContent = true;
            }
        }
        
        if (!rowHasContent) {
            continue; // Skip empty rows
        }
        
        // Optimize row direction (bidirectional scanning)
        var rowIndex = tempCanvas.height - 1 - canvasY;
        var isEvenRow = (rowIndex % 2) === 0;
        if (!isEvenRow) {
            rowData.reverse(); // Reverse odd rows for zigzag pattern
        }
        
        // Move to start of row
        var startX = isEvenRow ? 0 : (tempCanvas.width - 1) * pixelSize;
        if (Math.abs(startX - lastX) > 0.1) { // Only move if significant distance
            gcode.push('G0 X' + startX.toFixed(2) + ' Y' + yPos.toFixed(2) + ' F' + LASER_CONFIG.travelRate + ' ; Move to row ' + rowIndex);
            lastX = startX;
        } else {
            gcode.push('G0 Y' + yPos.toFixed(2) + ' ; Next row ' + rowIndex);
        }
        
        // Process pixels in this row
        var segmentStart = null;
        var segmentPower = 0;
        
        for (var i = 0; i < rowData.length; i++) {
            var pixel = rowData[i];
            var xPos = pixel.x * pixelSize;
            
            if (pixel.power > 0) {
                if (segmentStart === null) {
                    // Start new laser segment
                    segmentStart = xPos;
                    segmentPower = pixel.power;
                    
                    if (currentLaserPower !== pixel.power) {
                        gcode.push('M106 S' + pixel.power + ' ; Laser power ' + Math.round((pixel.power/255)*100) + '%');
                        currentLaserPower = pixel.power;
                    }
                    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Engraving speed');
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Start burn');
                } else if (Math.abs(pixel.power - segmentPower) > 5) {
                    // Power change - end current segment and start new one
                    gcode.push('G1 X' + xPos.toFixed(2) + ' ; Continue burn');
                    gcode.push('M106 S' + pixel.power + ' ; Power change to ' + Math.round((pixel.power/255)*100) + '%');
                    segmentPower = pixel.power;
                    currentLaserPower = pixel.power;
                } else {
                    // Continue current segment
                    if (i === rowData.length - 1 || i % 5 === 0) { // Output position every 5 pixels or at end
                        gcode.push('G1 X' + xPos.toFixed(2) + ' ; Burn');
                    }
                }
            } else {
                if (segmentStart !== null) {
                    // End laser segment
                    gcode.push(LASER_CONFIG.laserOff + ' ; End burn segment');
                    currentLaserPower = 0;
                    segmentStart = null;
                }
                
                // Skip to next burning pixel if there are any
                var nextBurnIndex = -1;
                for (var j = i + 1; j < rowData.length; j++) {
                    if (rowData[j].power > 0) {
                        nextBurnIndex = j;
                        break;
                    }
                }
                
                if (nextBurnIndex > -1 && nextBurnIndex - i > 3) {
                    // Jump to next burn area if it's far enough
                    var nextXPos = rowData[nextBurnIndex].x * pixelSize;
                    gcode.push('G0 X' + nextXPos.toFixed(2) + ' F' + LASER_CONFIG.travelRate + ' ; Skip to next burn area');
                    i = nextBurnIndex - 1; // -1 because loop will increment
                    lastX = nextXPos;
                }
            }
            
            lastX = xPos;
        }
        
        // Ensure laser is off at end of row
        if (currentLaserPower > 0) {
            gcode.push(LASER_CONFIG.laserOff + ' ; End of row');
            currentLaserPower = 0;
        }
        
        // Progress indicator
        if (rowIndex % 50 === 0) {
            var progress = Math.round((rowIndex / tempCanvas.height) * 100);
            gcode.push('; Progress: ' + progress + '% (row ' + rowIndex + '/' + tempCanvas.height + ')');
        }
    }
    
    return gcode.join('\n');
}

/**
 * Process text object and generate G-code for vector engraving
 */
function processTextToGcode(textObj) {
    console.log('Processing text for laser engraving...');
    
    var bounds = textObj.getBoundingRect();
    var xOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.left - WORKSPACE_CONFIG.usableArea.offsetX);
    var yOffsetMm = WORKSPACE_CONFIG.pixelsToMm(bounds.top - WORKSPACE_CONFIG.usableArea.offsetY);
    var widthMm = WORKSPACE_CONFIG.pixelsToMm(bounds.width);
    var heightMm = WORKSPACE_CONFIG.pixelsToMm(bounds.height);
    
    var gcode = [];
    gcode.push('; Vector text engraving: "' + textObj.text + '"');
    gcode.push('; Font: ' + textObj.fontFamily + ', Size: ' + WORKSPACE_CONFIG.pixelsToMm(textObj.fontSize).toFixed(1) + 'mm');
    gcode.push('; Position: X' + xOffsetMm.toFixed(1) + ' Y' + yOffsetMm.toFixed(1));
    gcode.push('; Dimensions: ' + widthMm.toFixed(1) + 'x' + heightMm.toFixed(1) + 'mm');
    gcode.push('');
    
    // For text, we'll create a simple outline engraving
    var laserPower = Math.round(LASER_CONFIG.maxPower * 0.7); // 70% power for text
    
    gcode.push('; Text outline engraving');
    gcode.push('G0 X' + xOffsetMm.toFixed(2) + ' Y' + yOffsetMm.toFixed(2) + ' ; Move to text start');
    gcode.push('M106 S' + laserPower + ' ; Set laser power to ' + Math.round((laserPower/255)*100) + '%');
    gcode.push('F' + LASER_CONFIG.feedRate + ' ; Set engraving speed');
    
    // Create a simple rectangular outline for text (in a real implementation, you'd trace the actual font paths)
    gcode.push('G1 X' + (xOffsetMm + widthMm).toFixed(2) + ' ; Right edge');
    gcode.push('G1 Y' + (yOffsetMm + heightMm).toFixed(2) + ' ; Top edge');  
    gcode.push('G1 X' + xOffsetMm.toFixed(2) + ' ; Left edge');
    gcode.push('G1 Y' + yOffsetMm.toFixed(2) + ' ; Bottom edge');
    
    gcode.push(LASER_CONFIG.laserOff + ' ; Turn off laser');
    
    return gcode.join('\n');
}

/**
 * Export canvas content as G-code for laser engraving
 */
function downloadGcode() {
    // Check if there's anything on the canvas to export (excluding grid)
    var exportableObjects = canvas.getObjects().filter(function(obj) {
        return !obj.excludeFromExport;
    });

    if (exportableObjects.length === 0) {
        alert('Le canevas est vide. Ajoutez des objets avant d\'exporter.');
        return;
    }

    console.log('Generating G-code for the entire canvas as a single image...');

    var gcode = [];

    // Add header
    gcode.push(generateGcodeHeader());

    // Process the entire canvas as one image
    gcode.push('; Processing entire canvas as a single image');
    var canvasGcode = processCanvasToGcode(); // This function handles the whole canvas
    if (canvasGcode && canvasGcode.trim() !== '') {
        gcode.push(canvasGcode);
    } else {
        console.log('processCanvasToGcode returned empty or whitespace only G-code. This might happen if the canvas is effectively blank.');
        // Optionally, you could alert the user here or add a comment to the G-code file.
        gcode.push('; Warning: Canvas content resulted in empty G-code.');
    }
    gcode.push(''); // Add a blank line for separation

    // Add footer
    gcode.push(generateGcodeFooter());

    var finalGcode = gcode.join('\n');

    // Show preview of G-code
    console.log('Generated G-code:');
    console.log(finalGcode);

    // Create file and download
    var blob = new Blob([finalGcode], { type: 'text/plain' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    // Changed filename to reflect it's a full canvas export
    a.download = currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '_canvas.gcode';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Show success message
    alert('G-code généré avec succès pour l\'ensemble du canevas!\n\n' +
          'Fichier: ' + a.download + '\n\n' +
          'Configuration laser:\n' +
          '- Commande ON: M106 (contrôle du ventilateur)\n' +
          '- Commande OFF: M107\n' +
          '- Puissance max: ' + LASER_CONFIG.maxPower + ' (PWM)\n' +
          '- Vitesse gravure: ' + LASER_CONFIG.feedRate + ' mm/min\n' +
          '- Vitesse déplacement: ' + LASER_CONFIG.travelRate + ' mm/min');
}

/**
 * Update laser configuration from UI
 */
function updateLaserConfig() {
    var maxPowerInput = document.getElementById('maxPower');
    var feedRateInput = document.getElementById('feedRate');
    var travelRateInput = document.getElementById('travelRate');
    var statusElement = document.getElementById('laserStatus');
    
    if (maxPowerInput) LASER_CONFIG.maxPower = parseInt(maxPowerInput.value) || 255;
    if (feedRateInput) LASER_CONFIG.feedRate = parseInt(feedRateInput.value) || 1000;
    if (travelRateInput) LASER_CONFIG.travelRate = parseInt(travelRateInput.value) || 3000;
    
    if (statusElement) {
        statusElement.textContent = `Configuration mise à jour: ${LASER_CONFIG.maxPower} PWM, ${LASER_CONFIG.feedRate}/${LASER_CONFIG.travelRate} mm/min`;
        statusElement.style.color = '#28a745';
        
        // Reset color after 3 seconds
        setTimeout(function() {
            if (statusElement) {
                statusElement.style.color = '#666';
            }
        }, 3000);
    }
    
    console.log('Laser config updated:', LASER_CONFIG);
}
